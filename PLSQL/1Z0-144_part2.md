### PL/SQL Exceptions

- handle exceptions in three ways:

  - 1. trap: catch it and take some actions
  - 2. propagate: directly propagate it to the calling subprogram or environment
  - 3. Trap & propagate

- three types of exceptions

  - Predefined Oracle Servers Errors
  - Non-predefined Oracle Server Errors
  - User-defined Errors

- `sqlcode` the error code of the exception
  - returns NULL when no errors occurred
- `sqlerrm` sql error message, error message for the exception

```sql
declare
    ...
begin
    {an exception occurs here}
exception
    when exception_name then
        ...
    when others then
        ...
end;
```

Handing the Exceptions

```sql

----------------- sqlerrm & sqlcode example
declare
  v_name varchar2(6);
  v_department_name varchar2(100);
begin

  select first_name into v_name from employees where employee_id = 103;
  select department_id into v_department_name from employees where first_name = v_name;
  dbms_output.put_line('Hello '|| v_name || '. Your department id is : '|| v_department_name );

exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the selected id');
  when too_many_rows then
    dbms_output.put_line('There are more than one employees with the name '|| v_name);
    dbms_output.put_line('Try with a different employee');
  when others then
    dbms_output.put_line('An unexpected error happened. Connect with the programmer..');
    dbms_output.put_line(sqlcode || ' ---> '|| sqlerrm);
end;

----------------- Inner block exception example
declare
  v_name varchar2(6);
  v_department_name varchar2(100);
begin
  select first_name into v_name from employees where employee_id = 100;
  begin
    select department_id into v_department_name from employees where first_name = v_name;
    exception
      when too_many_rows then
      v_department_name := 'Error in department_name';
  end;
  dbms_output.put_line('Hello '|| v_name || '. Your department id is : '|| v_department_name );
exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the selected id');
  when too_many_rows then
    dbms_output.put_line('There are more than one employees with the name '|| v_name);
    dbms_output.put_line('Try with a different employee');
  when others then
    dbms_output.put_line('An unexpected error happened. Connect with the programmer..');
    dbms_output.put_line(sqlcode || ' ---> '|| sqlerrm);
end;
/
```

Handing Non-predefined Exception

- Unnamed Exceptions
- can't trap with the error codes
- declare exceptions with the error codes
  - `exception_name EXCEPTION;`
  - `pragma exception_init(exception_name, error_code);`
- PRAGMA is a compiler directive or hint, used to provide an instruction to the complier.

```sql
begin
  UPDATE employees_copy set email = null where employee_id = 100;
end;

-----------------HANDLING a non-predefined exception
declare
  cannot_update_to_null exception;
  pragma exception_init(cannot_update_to_null,-01407);
begin
  UPDATE employees_copy set email = null where employee_id = 100;
exception
  when cannot_update_to_null then
    dbms_output.put_line('You cannot update with a null value!');
end;
```

Handling & Raising User-Defined Exceptions

- these exceptions are not an error of the database

```sql
exception_name EXCEPTION;
RAISE exception_name;
```

```sql

/*************** Creating a User defined Exception *****************/
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise too_high_salary;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

/**************** Raising a Predefined Exception *******************/
declare
  v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise invalid_number;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when invalid_number then
    dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

/****************** Raising Inside of the Exception ****************/
declare
  v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise invalid_number;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when invalid_number then
    dbms_output.put_line('This salary is too high. You need to decrease it.');
 raise; -- raise same exception again
end;

```

Using RAISE_APPLICATION_ERROR()

- to raise an exception out of the block
- raise_application_error raises the error to the caller
  `raise_application_error(error_number, error_message [, TRUE | FALSE]);`
- `TRUE|FALSE` true turn on the error stack
- Error number must be between `-20000` and `-20999`

```SQL
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    --raise too_high_salary;
 raise_application_error(-20243,'The salary of the selected employee is too high!');
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

----------------- raise inside of the exception section
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise too_high_salary;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
  raise_application_error(-01403,'The salary of the selected employee is too high!',true);
end;
```

### Functions & Procedures

```sql
create [or replace] procedure procedure_name
    [(parameter_name [IN | OUT | IN OUT] type [, ...])] {IS | AS}
begin
    ...
exception
    ...
end;
```

```sql
----------------- Creating a procedure
create procedure increase_salaries as
    cursor c_emps is select * from employees_copy for update;
    v_salary_increase number := 1.10;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
end;

----------------- Multiple procedure usage
begin
  dbms_output.put_line('Increasing the salaries!...');
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  dbms_output.put_line('All the salaries are successfully increased!...');
end;

----------------- Different procedures in one block
begin
  dbms_output.put_line('Increasing the salaries!...');
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  dbms_output.put_line('All the salaries are successfully increased!...');
end;

-----------------Creating a procedure to ease the dbms_output.put_line procedure
create procedure new_line as
begin
  dbms_output.put_line('------------------------------------------');
end;

-----------------Modifying the procedure with using the OR REPLACE command.
create or replace procedure increase_salaries as
    cursor c_emps is select * from employees_copy for update;
    v_salary_increase number := 1.10;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
    dbms_output.put_line('Procedure finished executing!');
end
```

Using IN & OUT Parameters

- without specify then `IN` by default

```sql

-----------------Creating a procedure with the IN parameters
create or replace procedure increase_salaries (v_salary_increase in number, v_department_id pls_integer) as
    cursor c_emps is select * from employees_copy where department_id = v_department_id for update;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
    dbms_output.put_line('Procedure finished executing!');
end;

----------------- Creating a procedure with the OUT parameters
create or replace procedure increase_salaries
    (v_salary_increase in out number, v_department_id pls_integer, v_affected_employee_count out number) as
    cursor c_emps is select * from employees_copy where department_id = v_department_id for update;
    v_old_salary number;
    v_sal_inc number := 0;
begin
    v_affected_employee_count := 0;
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
      v_affected_employee_count := v_affected_employee_count + 1;
      v_sal_inc := v_sal_inc + v_salary_increase + nvl(r_emp.commission_pct,0);
    end loop;
    v_salary_increase := v_sal_inc / v_affected_employee_count;
    dbms_output.put_line('Procedure finished executing!');
end;

-----------------Another example of creating a procedure with the IN parameter
CREATE OR REPLACE PROCEDURE PRINT(TEXT IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(TEXT);
END;

-----------------Using the procedures that has the IN parameters
begin
 PRINT('SALARY INCREASE STARTED!..');
 INCREASE_SALARIES(1.15,90);
 PRINT('SALARY INCREASE FINISHED!..');
end;

-----------------Using the procedure that has OUT parameters
declare
  v_sal_inc number := 1.2;
  v_aff_emp_count number;
begin
 PRINT('SALARY INCREASE STARTED!..');
 INCREASE_SALARIES(v_sal_inc,80,v_aff_emp_count);
 PRINT('The affected employee count is : '|| v_aff_emp_count);
 PRINT('The average salary increase is : '|| v_sal_inc || ' percent!..');
 PRINT('SALARY INCREASE FINISHED!..');
end;
```

Named & Mixed Notations and Default Option

- run the procedures with or without functions
- with the DEFAULT option
- Named notation allows us to pass parameter independent from the position
  - with the named notation `=>`  
    `EXECUTE procedure_name(parameter_name => value|expression);`

```sql
create [or replace] procedure procedure_name
    [(parameter_name [IN | OUT | IN OUT] type DEFAULT value|expression [, ...])] {IS | AS}
```

```sql

----------------- A standard procedure creation with a default value
create or replace PROCEDURE PRINT(TEXT IN VARCHAR2 := 'This is the print function!.') IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(TEXT);
END;

-----------------Executing a procedure without any parameter. It runs because it has a default value.
exec print();

-----------------Running a procedure with null value will not use the default value
exec print(null);

-----------------Procedure creation of a default value usage
create or replace procedure add_job(job_id pls_integer, job_title varchar2,
                                    min_salary number default 1000, max_salary number default null) is
begin
  insert into jobs values (job_id,job_title,min_salary,max_salary);
  print('The job : '|| job_title || ' is inserted!..');
end;

-----------------A standard run of the procedure
exec ADD_JOB('IT_DIR','IT Director',5000,20000);

-----------------Running a procedure with using the default values
exec ADD_JOB('IT_DIR2','IT Director',5000);

-----------------Running a procedure with the named notation
exec ADD_JOB('IT_DIR5','IT Director',max_salary=>10000);

-----------------Running a procedure with the named notation example 2
exec ADD_JOB(job_title=>'IT Director',job_id=>'IT_DIR7',max_salary=>10000 , min_salary=>500);
```

Creating and Using PL/SQL Function

```sql
CREATE OR REPLACE FUNCTION get_avg_sal (p_dept_id departments.department_id%type) RETURN number AS
v_avg_sal number;
BEGIN
  select avg(salary) into v_avg_sal from employees where department_id = p_dept_id;
  RETURN v_avg_sal;
END get_avg_sal;
----------------- using a function in begin-end block
declare
  v_avg_salary number;
begin
  v_avg_salary := get_avg_sal(50);
  dbms_output.put_line(v_avg_salary);
end;
----------------- using functions in a select clause
select employee_id,first_name,salary,department_id,get_avg_sal(department_id) avg_sal from employees;
----------------- using functions in group by, order by, where clauses
select get_avg_sal(department_id) from employees
where salary > get_avg_sal(department_id)
group by get_avg_sal(department_id)
order by get_avg_sal(department_id);
----------------- dropping a function
drop function get_avg_sal;
```
