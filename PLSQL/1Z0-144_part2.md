### PL/SQL Exceptions

- handle exceptions in three ways:

  - 1. trap: catch it and take some actions
  - 2. propagate: directly propagate it to the calling subprogram or environment
  - 3. Trap & propagate

- three types of exceptions

  - Predefined Oracle Servers Errors
  - Non-predefined Oracle Server Errors
  - User-defined Errors

- `sqlcode` the error code of the exception
  - returns NULL when no errors occurred
- `sqlerrm` sql error message, error message for the exception

```sql
declare
    ...
begin
    {an exception occurs here}
exception
    when exception_name then
        ...
    when others then
        ...
end;
```

Handing the Exceptions

```sql

----------------- sqlerrm & sqlcode example
declare
  v_name varchar2(6);
  v_department_name varchar2(100);
begin

  select first_name into v_name from employees where employee_id = 103;
  select department_id into v_department_name from employees where first_name = v_name;
  dbms_output.put_line('Hello '|| v_name || '. Your department id is : '|| v_department_name );

exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the selected id');
  when too_many_rows then
    dbms_output.put_line('There are more than one employees with the name '|| v_name);
    dbms_output.put_line('Try with a different employee');
  when others then
    dbms_output.put_line('An unexpected error happened. Connect with the programmer..');
    dbms_output.put_line(sqlcode || ' ---> '|| sqlerrm);
end;

----------------- Inner block exception example
declare
  v_name varchar2(6);
  v_department_name varchar2(100);
begin
  select first_name into v_name from employees where employee_id = 100;
  begin
    select department_id into v_department_name from employees where first_name = v_name;
    exception
      when too_many_rows then
      v_department_name := 'Error in department_name';
  end;
  dbms_output.put_line('Hello '|| v_name || '. Your department id is : '|| v_department_name );
exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the selected id');
  when too_many_rows then
    dbms_output.put_line('There are more than one employees with the name '|| v_name);
    dbms_output.put_line('Try with a different employee');
  when others then
    dbms_output.put_line('An unexpected error happened. Connect with the programmer..');
    dbms_output.put_line(sqlcode || ' ---> '|| sqlerrm);
end;
/
```

Handing Non-predefined Exception

- Unnamed Exceptions
- can't trap with the error codes
- declare exceptions with the error codes
  - `exception_name EXCEPTION;`
  - `pragma exception_init(exception_name, error_code);`
- PRAGMA is a compiler directive or hint, used to provide an instruction to the complier.

```sql
begin
  UPDATE employees_copy set email = null where employee_id = 100;
end;

-----------------HANDLING a non-predefined exception
declare
  cannot_update_to_null exception;
  pragma exception_init(cannot_update_to_null,-01407);
begin
  UPDATE employees_copy set email = null where employee_id = 100;
exception
  when cannot_update_to_null then
    dbms_output.put_line('You cannot update with a null value!');
end;
```

Handling & Raising User-Defined Exceptions

- these exceptions are not an error of the database

```sql
exception_name EXCEPTION;
RAISE exception_name;
```

```sql

/*************** Creating a User defined Exception *****************/
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise too_high_salary;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

/**************** Raising a Predefined Exception *******************/
declare
  v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise invalid_number;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when invalid_number then
    dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

/****************** Raising Inside of the Exception ****************/
declare
  v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise invalid_number;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when invalid_number then
    dbms_output.put_line('This salary is too high. You need to decrease it.');
 raise; -- raise same exception again
end;

```

Using RAISE_APPLICATION_ERROR()

- to raise an exception out of the block
- raise_application_error raises the error to the caller
  `raise_application_error(error_number, error_message [, TRUE | FALSE]);`
- `TRUE|FALSE` true turn on the error stack
- Error number must be between `-20000` and `-20999`

```SQL
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    --raise too_high_salary;
 raise_application_error(-20243,'The salary of the selected employee is too high!');
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
end;

----------------- raise inside of the exception section
declare
too_high_salary exception;
v_salary_check pls_integer;
begin
  select salary into v_salary_check from employees where employee_id = 100;
  if v_salary_check > 20000 then
    raise too_high_salary;
  end if;
  --we do our business if the salary is under 2000
  dbms_output.put_line('The salary is in an acceptable range');
exception
  when too_high_salary then
  dbms_output.put_line('This salary is too high. You need to decrease it.');
  raise_application_error(-01403,'The salary of the selected employee is too high!',true);
end;
```

### Functions & Procedures

```sql
create [or replace] procedure procedure_name
    [(parameter_name [IN | OUT | IN OUT] type [, ...])] {IS | AS}
begin
    ...
exception
    ...
end;
```

```sql
----------------- Creating a procedure
create procedure increase_salaries as
    cursor c_emps is select * from employees_copy for update;
    v_salary_increase number := 1.10;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
end;

----------------- Multiple procedure usage
begin
  dbms_output.put_line('Increasing the salaries!...');
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  INCREASE_SALARIES;
  dbms_output.put_line('All the salaries are successfully increased!...');
end;

----------------- Different procedures in one block
begin
  dbms_output.put_line('Increasing the salaries!...');
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  new_line;
  INCREASE_SALARIES;
  dbms_output.put_line('All the salaries are successfully increased!...');
end;

-----------------Creating a procedure to ease the dbms_output.put_line procedure
create procedure new_line as
begin
  dbms_output.put_line('------------------------------------------');
end;

-----------------Modifying the procedure with using the OR REPLACE command.
create or replace procedure increase_salaries as
    cursor c_emps is select * from employees_copy for update;
    v_salary_increase number := 1.10;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
    dbms_output.put_line('Procedure finished executing!');
end
```

Using IN & OUT Parameters

- without specify then `IN` by default

```sql

-----------------Creating a procedure with the IN parameters
create or replace procedure increase_salaries (v_salary_increase in number, v_department_id pls_integer) as
    cursor c_emps is select * from employees_copy where department_id = v_department_id for update;
    v_old_salary number;
begin
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
    end loop;
    dbms_output.put_line('Procedure finished executing!');
end;

----------------- Creating a procedure with the OUT parameters
create or replace procedure increase_salaries
    (v_salary_increase in out number, v_department_id pls_integer, v_affected_employee_count out number) as
    cursor c_emps is select * from employees_copy where department_id = v_department_id for update;
    v_old_salary number;
    v_sal_inc number := 0;
begin
    v_affected_employee_count := 0;
    for r_emp in c_emps loop
      v_old_salary := r_emp.salary;
      r_emp.salary := r_emp.salary * v_salary_increase + r_emp.salary * nvl(r_emp.commission_pct,0);
      update employees_copy set row = r_emp where current of c_emps;
      dbms_output.put_line('The salary of : '|| r_emp.employee_id
                            || ' is increased from '||v_old_salary||' to '||r_emp.salary);
      v_affected_employee_count := v_affected_employee_count + 1;
      v_sal_inc := v_sal_inc + v_salary_increase + nvl(r_emp.commission_pct,0);
    end loop;
    v_salary_increase := v_sal_inc / v_affected_employee_count;
    dbms_output.put_line('Procedure finished executing!');
end;

-----------------Another example of creating a procedure with the IN parameter
CREATE OR REPLACE PROCEDURE PRINT(TEXT IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(TEXT);
END;

-----------------Using the procedures that has the IN parameters
begin
 PRINT('SALARY INCREASE STARTED!..');
 INCREASE_SALARIES(1.15,90);
 PRINT('SALARY INCREASE FINISHED!..');
end;

-----------------Using the procedure that has OUT parameters
declare
  v_sal_inc number := 1.2;
  v_aff_emp_count number;
begin
 PRINT('SALARY INCREASE STARTED!..');
 INCREASE_SALARIES(v_sal_inc,80,v_aff_emp_count);
 PRINT('The affected employee count is : '|| v_aff_emp_count);
 PRINT('The average salary increase is : '|| v_sal_inc || ' percent!..');
 PRINT('SALARY INCREASE FINISHED!..');
end;
```

Named & Mixed Notations and Default Option

- run the procedures with or without functions
- with the DEFAULT option
- Named notation allows us to pass parameter independent from the position
  - with the named notation `=>`  
    `EXECUTE procedure_name(parameter_name => value|expression);`

```sql
create [or replace] procedure procedure_name
    [(parameter_name [IN | OUT | IN OUT] type DEFAULT value|expression [, ...])] {IS | AS}
```

```sql

----------------- A standard procedure creation with a default value
create or replace PROCEDURE PRINT(TEXT IN VARCHAR2 := 'This is the print function!.') IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(TEXT);
END;

-----------------Executing a procedure without any parameter. It runs because it has a default value.
exec print();

-----------------Running a procedure with null value will not use the default value
exec print(null);

-----------------Procedure creation of a default value usage
create or replace procedure add_job(job_id pls_integer, job_title varchar2,
                                    min_salary number default 1000, max_salary number default null) is
begin
  insert into jobs values (job_id,job_title,min_salary,max_salary);
  print('The job : '|| job_title || ' is inserted!..');
end;

-----------------A standard run of the procedure
exec ADD_JOB('IT_DIR','IT Director',5000,20000);

-----------------Running a procedure with using the default values
exec ADD_JOB('IT_DIR2','IT Director',5000);

-----------------Running a procedure with the named notation
exec ADD_JOB('IT_DIR5','IT Director',max_salary=>10000);

-----------------Running a procedure with the named notation example 2
exec ADD_JOB(job_title=>'IT Director',job_id=>'IT_DIR7',max_salary=>10000 , min_salary=>500);
```

Creating and Using PL/SQL Function

- must return a value
- can be used within a select statement
- can assign a function to a variable

Differences and Similarities of Functions & Procedures

- Procedures are executed within a begin-end block or with execute command
- Functions are used within an SQL Query or assigned to some variable
- pass IN & OUT parameters to both
- Procedures does not return a value, but functions return

The restrictions of using functions in SQL expressions

- must be compiled and stored in the database
- must return a valid type of the SQL Data Types
- cannot be used in table creation codes
- cannot call a function that contains a DML Statement, can't use it within an SQL query
- cannot call a function that contains COMMIT, ROLLBACK or DDL Statements, can't use it within an SQL query
- if the function has a DML operation of the specified table, can't use it within the SQL query related to that table
- need to have the related privilege

```sql
create [or replace] function function_name
    [(parameter_name [IN | OUT | IN OUT] type DEFAULT value|expression [, ...])] return return_data_type {IS | AS}
```

```sql

CREATE OR REPLACE FUNCTION get_avg_sal (p_dept_id departments.department_id%type) RETURN number AS
v_avg_sal number;
BEGIN
  select avg(salary) into v_avg_sal from employees where department_id = p_dept_id;
  RETURN v_avg_sal;
END get_avg_sal;

----------------- using a function in begin-end block
declare
  v_avg_salary number;
begin
  v_avg_salary := get_avg_sal(50);
  dbms_output.put_line(v_avg_salary);
end;

----------------- using functions in a select clause
select employee_id,first_name,salary,department_id,get_avg_sal(department_id) avg_sal from employees;

----------------- using functions in group by, order by, where clauses
select get_avg_sal(department_id) from employees
where salary > get_avg_sal(department_id)
group by get_avg_sal(department_id)
order by get_avg_sal(department_id);

----------------- dropping a function
drop function get_avg_sal;
```

Local Subprograms

- reduce code repetition
- improve code readability
- need no more privilege

```sql
*******************************************************************/


declare

  procedure insert_high_paid_emp(emp_id employees.employee_id%type) is
    emp employees%rowtype;
    begin
      emp := get_emp(emp_id);
      insert into emps_high_paid values emp;
    end;

  function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
    emp employees%rowtype;
    begin
      select * into emp from employees where employee_id = emp_num;
      return emp;
    end;

begin
  for r_emp in (select * from employees) loop
    if r_emp.salary > 15000 then
      insert_high_paid_emp(r_emp.employee_id);
    end if;
  end loop;
end;

/* Creating and Using Subprograms in Anonymous Blocks - True Usage */
declare

  function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
    emp employees%rowtype;
    begin
      select * into emp from employees where employee_id = emp_num;
      return emp;
    end;

  procedure insert_high_paid_emp(emp_id employees.employee_id%type) is
    emp employees%rowtype;
    begin
      emp := get_emp(emp_id);
      insert into emps_high_paid values emp;
    end;

begin
  for r_emp in (select * from employees) loop
    if r_emp.salary > 15000 then
      insert_high_paid_emp(r_emp.employee_id);
    end if;
  end loop;
end;

/*********************** The Scope of Emp Record **********************/
declare

  procedure insert_high_paid_emp(emp_id employees.employee_id%type) is
    emp employees%rowtype;
    e_id number;
    -- local function inside procedure declare block
    -- should be last position in the declaration area
    function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
      begin
        select * into emp from employees where employee_id = emp_num;
        return emp;
      end;

    begin
      emp := get_emp(emp_id);
      insert into emps_high_paid values emp;
    end;

begin
  for r_emp in (select * from employees) loop
    if r_emp.salary > 15000 then
      insert_high_paid_emp(r_emp.employee_id);
    end if;
  end loop;
end;
```

Overloading the Subprograms

- overloading means creating more than one subprogram with the same name
- overloading the subprograms with same name but with different parameters
  - if parameters are in the same family or subtype, it won't work
- overloading is pretty useful when using subprograms with packages

```sql
declare
  procedure insert_high_paid_emp(p_emp employees%rowtype) is
    emp employees%rowtype;
    e_id number;

    function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
      begin
        select * into emp from employees where employee_id = emp_num;
        return emp;
      end;

    function get_emp(emp_email employees.email%type) return employees%rowtype is
      begin
        select * into emp from employees where email = emp_email;
        return emp;
      end;

    begin
      emp := get_emp(p_emp.employee_id);
      insert into emps_high_paid values emp;
    end;
begin

  for r_emp in (select * from employees) loop
    if r_emp.salary > 15000 then
      insert_high_paid_emp(r_emp);
    end if;
  end loop;
end;

----------------- overloading with multiple usages
declare
  procedure insert_high_paid_emp(p_emp employees%rowtype) is
    emp employees%rowtype;
    e_id number;

    function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
      begin
        select * into emp from employees where employee_id = emp_num;
        return emp;
      end;

    function get_emp(emp_email employees.email%type) return employees%rowtype is
      begin
        select * into emp from employees where email = emp_email;
        return emp;
      end;

    function get_emp(f_name varchar2, l_name varchar2) return employees%rowtype is
      begin
        select * into emp from employees where first_name = f_name and last_name = l_name;
        return emp;
      end;

    begin
      emp := get_emp(p_emp.employee_id);
      insert into emps_high_paid values emp;
      emp := get_emp(p_emp.email);
      insert into emps_high_paid values emp;
      emp := get_emp(p_emp.first_name,p_emp.last_name);
      insert into emps_high_paid values emp;
    end;

begin
  for r_emp in (select * from employees) loop
    if r_emp.salary > 15000 then
      insert_high_paid_emp(r_emp);
    end if;
  end loop;
end;
```

Handing the Exception in Subprograms

```sql

----------------- An unhandled exception in function
create or replace function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
  emp employees%rowtype;
 begin
   select * into emp from employees where employee_id = emp_num;
  return emp;
 end;

----------------- calling that function in an anonymous block
declare
  v_emp employees%rowtype;
begin
  dbms_output.put_line('Fetching the employee data!..');
  v_emp := get_emp(10);
  dbms_output.put_line('Some information of the employee are : ');
  dbms_output.put_line('The name of the employee is : '|| v_emp.first_name);
  dbms_output.put_line('The email of the employee is : '|| v_emp.email);
  dbms_output.put_line('The salary of the employee is : '|| v_emp.salary);
end;

/* ERROR Example */
----------------- handling the exception without the return clause - not working
create or replace function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
  emp employees%rowtype;
 begin
   select * into emp from employees where employee_id = emp_num;
  return emp;
 exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the id '|| emp_num);
 end;

/* ERROR Example */
----------------- handling and raising the exception
create or replace function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
  emp employees%rowtype;
 begin
   select * into emp from employees where employee_id = emp_num;
  return emp;
 exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the id '|| emp_num);
    raise no_data_found;
 end;

----------------- handling all possible exception cases
create or replace function get_emp(emp_num employees.employee_id%type) return employees%rowtype is
  emp employees%rowtype;
 begin
   select * into emp from employees where employee_id = emp_num;
  return emp;
 exception
  when no_data_found then
    dbms_output.put_line('There is no employee with the id '|| emp_num);
    return null;
  when others then
    dbms_output.put_line('Something unexpected happened!.');
 return null;
 end;
```

Finding & Removing the Subprograms

```sql
select * from user_source;
```

Regular & Pipelined Table Functions

- table functions return a table of varray or nested tables
- regular table functions returns after completing the whole data
- pipelined functions return each row one by one
  - it returns object

```sql
CREATE TYPE t_day AS OBJECT (
  v_date DATE,
  v_day_number INT
);

----------------- creating a nested table type
CREATE TYPE t_days_tab IS TABLE OF t_day;


----------------- creating a regular table function
CREATE OR REPLACE FUNCTION f_get_days(p_start_date DATE , p_day_number INT)
              RETURN t_days_tab IS
v_days t_days_tab := t_days_tab();
BEGIN
 FOR i IN 1 .. p_day_number LOOP
  v_days.EXTEND();
  v_days(i) := t_day(p_start_date + i, to_number(to_char(p_start_date + i, 'DDD')));
 END LOOP;
 RETURN v_days;
END;

----------------- querying from the regular table function
select * from table(f_get_days(sysdate,1000000));

----------------- querying from the regular table function without the table operator
select * from f_get_days(sysdate,1000000);

----------------- creating a pipelined table function
create or replace function f_get_days_piped (p_start_date date , p_day_number int)
              return t_days_tab PIPELINED is
begin
 for i in 1 .. p_day_number loop
    ROW (t_day(p_start_date + i,
                  to_number(to_char(p_start_date + i,'DDD'))));
 end loop;
 RETURN;
end;

----------------- querying from the pipelined table function
select * from f_get_days_piped(sysdate,1000000)
```

### Packages

- SGA (system global area): this is a memory area which shared by all of the users in the database.

Advantages of using packages

- modularity
- easy maintenance
- encapsulation & security
- performance
- functionality
- overloading

Creating & Using & Modifying & Removing the Packages

- a package consists of two parts
  - package specification (spec)
    - anyone who has the privilege will be able to use all the objects declared in the package specification
  - package body (body)
    - if a variable or a subprogram or any other object is not declared in the package spec, it's not visible to the others.
  -

```sql

----------------- Creating first package specification
CREATE OR REPLACE
PACKAGE EMP AS
  v_salary_increase_rate number := 0.057;
  cursor cur_emps is select * from employees;

  procedure increase_salaries;

  function get_avg_sal(p_dept_id int) return number;
END EMP;

----------------- Creating the package body
CREATE OR REPLACE
PACKAGE BODY EMP AS

  procedure increase_salaries AS
  BEGIN
    for r1 in cur_emps loop
      update employees_copy set salary = salary + salary * v_salary_increase_rate;
    end loop;
  END increase_salaries;

  function get_avg_sal(p_dept_id int) return number AS
  v_avg_sal number := 0;
  BEGIN
    select avg(salary) into v_avg_sal from employees_copy where
          department_id = p_dept_id;
    RETURN v_avg_sal;
  END get_avg_sal;

END EMP;

----------------- using the subprograms in packages
exec EMP_PKG.increase_salaries;

----------------- using the variables in packages
begin
  dbms_output.put_line(emp_pkg.get_avg_sal(50));
  dbms_output.put_line(emp_pkg.v_salary_increase_rate);
end;
```

Visibility of Package Objects

- inside of the package spec (all public)
- inside of the package body
  - package body private object has after `AS | IS` immediately

```sql
create or replace PACKAGE BODY EMP_PKG AS

  v_sal_inc int := 500;
  v_sal_inc2 int := 500;

  procedure print_test is
  begin
    dbms_output.put_line('Test : '|| v_sal_inc);
  end;

  procedure increase_salaries AS
  BEGIN
    for r1 in cur_emps loop
      update employees_copy set salary = salary + salary * v_salary_increase_rate
      where employee_id = r1.employee_id;
    end loop;
  END increase_salaries;

  function get_avg_sal(p_dept_id int) return number AS
  v_avg_sal number := 0;
  BEGIN
    print_test;
    select avg(salary) into v_avg_sal from employees_copy where
          department_id = p_dept_id;
    RETURN v_avg_sal;
  END get_avg_sal;

END EMP_PKG;

-----------------

create or replace PACKAGE BODY EMP_PKG AS

  v_sal_inc int := 500;
  v_sal_inc2 int := 500;
  function get_sal(e_id employees.employee_id%type) return number;
procedure print_test is
  begin
    dbms_output.put_line('Test : '|| v_sal_inc);
    dbms_output.put_line('Test salary : '|| get_sal(102));
  end;
  procedure increase_salaries AS
  BEGIN
    for r1 in cur_emps loop
      update employees_copy set salary = salary + salary * v_salary_increase_rate
      where employee_id = r1.employee_id;
    end loop;
  END increase_salaries;
  function get_avg_sal(p_dept_id int) return number AS
  v_avg_sal number := 0;
  BEGIN
    print_test;
    select avg(salary) into v_avg_sal from employees_copy where
          department_id = p_dept_id;
    RETURN v_avg_sal;
  END get_avg_sal;

  function get_sal(e_id employees.employee_id%type) return number is
  v_sal number := 0;
  begin
    select salary into v_sal from employees where employee_id = e_id;
  end;

  -- initialization block runs only at the first time that we refer to our package component a session
  -- run at first in a package body
  begin
    dbms_output.put_line('Package initialized block');
end;
```

Persistent State of Packages

- while the package is being copied, the public objects and the public variables of that package is copied into the PGA, but the subprograms are copied into the SGA
- variables and objects are stored in PGA, there variables are persistent for your session
- subprograms of the packages are stored in the SGA
- `PRAGMA SERIALLY_REUSABLE`: compiler directive, compiler that compile the package as its variables will be stored in the SGA
  - variable rolled back to initialize value after session completed
- serially reusable packages cannot be accessed from:
  - Triggers
  - Subprograms called from SQL Statements

```sql

execute dbms_output.put_line(constants_pkg.v_salary_increase);
grant execute on constants_pkg to my_user;
revoke execute on constants_pkg from my_user;
-----------------
-----------------
begin
  constants_pkg.v_company_name := 'ACME';
  dbms_output.put_line(constants_pkg.v_company_name);
  dbms_lock.sleep(20);
end;

exec dbms_output.put_line(constants_pkg.v_company_name);

-----------------
create or replace package constants_pkg is
PRAGMA SERIALLY_REUSABLE;
  v_salary_increase constant number:= 0.04; -- declare as constant
  cursor cur_emps is select * from employees;
  t_emps_type employees%rowtype;
  v_company_name varchar2(20) := 'ORACLE';
end;

-----------------
begin
  constants_pkg.v_company_name := 'ACME';
  dbms_output.put_line(constants_pkg.v_company_name);
  dbms_lock.sleep(20);
end;

-----------------
declare
v_emp employees%rowtype;
begin
 open constants_pkg.cur_emps;
 fetch constants_pkg.cur_emps into v_emp;
 dbms_output.put_line(v_emp.first_name);
 close constants_pkg.cur_emps;
end;
-- if doesn't close cursor, when call fetch again, then it will fetch the following value
-----------------
declare
v_emp employees%rowtype;
begin
 fetch constants_pkg.cur_emps into v_emp;
 dbms_output.put_line(v_emp.first_name);
end;
```

Using Collections in PL/SQL Packages

```sql
*******************************************************************/
CREATE OR REPLACE PACKAGE emp_pkg AS

  TYPE emp_table_type IS TABLE OF employees%rowtype INDEX BY PLS_INTEGER;

  v_salary_increase_rate NUMBER := 1000;
  v_min_employee_salary  NUMBER := 5000;

  CURSOR cur_emps IS
   SELECT * FROM employees;

  PROCEDURE increase_salaries;
  FUNCTION  get_avg_sal(p_dept_id int) RETURN NUMBER;

  v_test    INT := 4;

  FUNCTION  get_employees RETURN emp_table_type;
  FUNCTION  get_employees_tobe_incremented RETURN emp_table_type;
  PROCEDURE increase_low_salaries;
  FUNCTION  arrange_for_min_salary(v_emp employees%rowtype) RETURN employees%rowtype;

END EMP_PKG;

/************************** Package Body ***************************/
CREATE OR REPLACE PACKAGE BODY emp_pkg AS

  v_sal_inc INT  := 500;
  v_sal_inc2 INT := 500;

  -- forward declare function
  FUNCTION get_sal(e_id employees.employee_id%TYPE) RETURN NUMBER;

  PROCEDURE print_test IS
  BEGIN
    dbms_output.put_line('Test : '|| v_sal_inc);
    dbms_output.put_line('Tests salary :'|| get_sal(102));
  END;

  PROCEDURE increase_salaries AS
  BEGIN
    FOR r1 IN cur_emps LOOP
      UPDATE employees_copy
      SET    salary = salary + salary * v_salary_increase_rate
      WHERE employee_id = r1.employee_id;
    END LOOP;
  END increase_salaries;

  FUNCTION get_avg_sal(p_dept_id int) RETURN NUMBER AS
    v_avg_sal number := 0;
  BEGIN
  print_test;
    SELECT avg(salary)
    INTO   v_avg_sal
    FROM   employees_copy
    WHERE  department_id = p_dept_id;
    RETURN v_avg_sal;
  END get_avg_sal;

  FUNCTION get_sal(e_id employees.employee_id%TYPE) RETURN NUMBER IS
    v_sal number := 0;
  BEGIN
    SELECT salary
    INTO   v_sal
    FROM   employees
    WHERE  employee_id = e_id;
    RETURN v_sal;
  END;

  /* This function returns all the employees in employees table */
  FUNCTION get_employees RETURN emp_table_type IS
    v_emps emp_table_type;
  BEGIN
    FOR cur_emps IN (SELECT * FROM employees_copy) LOOP
      v_emps(cur_emps.employee_id) := cur_emps;
    END LOOP;
    RETURN v_emps;
  end;

  /*
    This function returns the employees which are under the minimum salary
    of the company standards and to be incremented by the new minimum salary
  */
  FUNCTION get_employees_tobe_incremented RETURN emp_table_type IS
    v_emps emp_table_type;
    i employees.employee_id%TYPE;
  BEGIN
    v_emps := get_employees;
    i := v_emps.first;
      WHILE i IS NOT NULL LOOP
        IF v_emps(i).salary > v_min_employee_salary THEN
          v_emps.delete(i);
        END IF;
        i := v_emps.next(i);
      END LOOP;
    RETURN v_emps;
  END;

  /*
    This procedure increases the salary of the employees
    who has a less salary then the company standard.
  */
  PROCEDURE increase_low_salaries AS
    v_emps emp_table_type;
    v_emp employees%rowtype;
    i employees.employee_id%type;
  BEGIN
    v_emps := get_employees_tobe_incremented;
    i := v_emps.first;
    WHILE i is not null loop
      v_emp := arrange_for_min_salary(v_emps(i));
      UPDATE employees_copy
      SET    row = v_emp
      WHERE  employee_id = i;
      i := v_emps.next(i);
    END LOOP;
  END increase_low_salaries;

  /*
    This function returns the employee by arranging the salary based on the
    company standard.
  */
  FUNCTION arrange_for_min_salary(v_emp in out employees%rowtype) RETURN employees%rowtype IS
  BEGIN
    v_emp.salary := v_emp.salary + v_salary_increase_rate;
    IF v_emp.salary < v_min_employee_salary THEN
      v_emp.salary := v_min_employee_salary;
    END IF;
    RETURN v_emp;
  END;
  /***************************************************************/
BEGIN
  v_salary_increase_rate := 500;
  INSERT INTO logs VALUES('EMP_PKG','Package initialized!',sysdate);
END emp_pkg;

```

### PL/SQL Triggers

- Triggers are PL/SQL blocks running when the specified event occurs.
- Triggers are executed automatically by the database server.
- Triggers are defined on tables, views, schemas, databases.
- Triggers are fired when one of these occurs:
  - when a DML (insert, update, delete) occurs
  - when a DDL (create, alter, drop) occurs
  - when some database operation occurs (logon, startup, server error, ...)
- There are three types of triggers:
  - DML triggers
  - Compound Triggers
  - Non-DML Triggers
- `CALL` statement for use a procedure

```sql
CREATE [OR REPLACE] TRIGGER  trigger_name Timing = BEFORE | AFTER | INSTEAD OF
Event = INSERT | UPDATE | DELETE | UPDATE OF column_list ON object_name
[ REFERENCE OLD AS old NEW AS new]
[ FOR EACH ROW]
[ WHEN (Condition) ]
[ DECLARE variables, types, etc]
BEGIN
    trigger_body
    [ EXCEPTION ]
END;
```

```sql
--------------------------
----------------- The create code of the first trigger
create or replace trigger first_trigger
before insert or update on employees_copy
begin
  dbms_output.put_line('An insert or update occurred in employees_copy table!.');
end;
----------------- sql commands to or not to run the trigger
update employees_copy set salary = salary + 100;
delete from employees_copy;
```

Statement & Row Level Triggers

```sql
----------------- before statement level trigger example
create or replace trigger before_statement_emp_cpy
before insert or update on employees_copy
begin
  dbms_output.put_line('Before Statement Trigger is Fired!.');
end;

----------------- after statement level trigger example
create or replace trigger after_statement_emp_cpy
after insert or update on employees_copy
begin
  dbms_output.put_line('After Statement Trigger is Fired!.');
end;

----------------- before row level trigger example
create or replace trigger before_row_emp_cpy
before insert or update on employees_copy
for each row
begin
  dbms_output.put_line('Before Row Trigger is Fired!.');
end;

----------------- after row level trigger example
create or replace trigger after_row_emp_cpy
after insert or update on employees_copy
for each row
begin
  dbms_output.put_line('After Row Trigger is Fired!.');
end;

----------------- sql queries used in this lecture
update employees_copy set salary = salary + 100 where employee_id = 100;
update employees_copy set salary = salary + 100 where employee_id = 99;
update employees_copy set salary = salary + 100
where department_id = 30;
```

Using New & Old Qualifiers in Triggers

- `:NEW` and `:OLD` qualifiers are used in row level triggers
- `:old.column_name` returns the old value, `:new.column_name` returns the new value

```sql
--------------------------
create or replace trigger before_row_emp_cpy
before insert or update or delete on employees_copy
referencing old as O new as N
for each row
begin
  dbms_output.put_line('Before Row Trigger is Fired!.');
  dbms_output.put_line('The Salary of Employee '||:o.employee_id
    ||' -> Before:'|| :o.salary||' After:'||:n.salary);
end;
```

Using Conditional Predicates

- `inserting`, `deleting`, `updating('column')`, `updating`

```sql
--------------------------
create or replace trigger before_row_emp_cpy
before insert or update or delete on employees_copy
referencing old as O new as N
for each row
begin
  dbms_output.put_line('Before Row Trigger is Fired!.');
  dbms_output.put_line('The Salary of Employee '||:o.employee_id
    ||' -> Before:'|| :o.salary||' After:'||:n.salary);
  if inserting then
    dbms_output.put_line('An INSERT occurred on employees_copy table');
  elsif deleting then
    dbms_output.put_line('A DELETE occurred on employees_copy table');
  elsif updating ('salary') then
    dbms_output.put_line('A DELETE occurred on the salary column');
  elsif updating then
    dbms_output.put_line('An UPDATE occurred on employees_copy table');
  end if;
end;
```

Using RAISE_APPLICATION_ERROR Procedure in Triggers

- a built-in procedure that returns an error to the user and causes PL/SQL code to fail

```sql
--------------------------
create or replace trigger before_row_emp_cpy
before insert or update or delete on employees_copy
referencing old as O new as N
for each row
begin
  dbms_output.put_line('Before Row Trigger is Fired!.');
  dbms_output.put_line('The Salary of Employee '||:o.employee_id
    ||' -> Before:'|| :o.salary||' After:'||:n.salary);
  if inserting then
    if :n.hire_date > sysdate then
      raise_application_error(-20000,'You cannot enter a future hire..');
    end if;
  elsif deleting then
    raise_application_error(-20001,'You cannot delete from the employees_copy table..');
  elsif updating ('salary') then
    if :n.salary > 50000 then
      raise_application_error(-20002,'A salary cannot be higher than 50000..');
    end if;
  elsif updating then
    dbms_output.put_line('An UPDATE occurred on employees_copy table');
  end if;
end;
```

Using Update Of Event in Triggers

```sql
--------------------------
create or replace trigger prevent_updates_of_constant_columns
before update of hire_date,salary on employees_copy
for each row
begin
  raise_application_error(-20005,'You cannot modify the hire_date and salary columns');
end;
```

Using WHEN Clause in Triggers

- the trigger is fired in all cases, but the body is not executed if the condition returns `NULL` or `FALSE`
- using without `:` for new and old qualifiers

```sql
--------------------------
create or replace trigger prevent_high_salary
before insert or update of salary on employees_copy
for each row
when (new.salary > 50000)
begin
  raise_application_error(-20006,'A salary cannot be higher than 50000!.');
end;
```

Instead of Triggers

- instead of triggers are used to apply some DML statements on un-updatable views
- instead of triggers are used only with the views
- generally used for the complex views
- if your view has a check option, it won't be enforced when you use the instead of triggers
- before and after timing options are not valid for instead of triggers

```sql
--------------------------
----------------- creating a complex view -----------------
CREATE OR REPLACE VIEW VW_EMP_DETAILS AS
  SELECT UPPER(DEPARTMENT_NAME) DNAME, MIN(SALARY) MIN_SAL, MAX(SALARY) MAX_SAL
    FROM EMPLOYEES_COPY JOIN DEPARTMENTS_COPY
    USING (DEPARTMENT_ID)
    GROUP BY DEPARTMENT_NAME;

----------------- updating the complex view -----------------
UPDATE VW_EMP_DETAILS SET DNAME = 'EXEC DEPT' WHERE
  UPPER(DNAME) = 'EXECUTIVE';

----------------- Instead of trigger -----------------
CREATE OR REPLACE TRIGGER EMP_DETAILS_VW_DML
  INSTEAD OF INSERT OR UPDATE OR DELETE ON VW_EMP_DETAILS
  FOR EACH ROW
  DECLARE
    V_DEPT_ID PLS_INTEGER;
  BEGIN

  IF INSERTING THEN
    SELECT MAX(DEPARTMENT_ID) + 10 INTO V_DEPT_ID FROM DEPARTMENTS_COPY;
    INSERT INTO DEPARTMENTS_COPY VALUES (V_DEPT_ID, :NEW.DNAME,NULL,NULL);
  ELSIF DELETING THEN
    DELETE FROM DEPARTMENTS_COPY WHERE UPPER(DEPARTMENT_NAME) = UPPER(:OLD.DNAME);
  ELSIF UPDATING('DNAME') THEN
    UPDATE DEPARTMENTS_COPY SET DEPARTMENT_NAME = :NEW.DNAME
      WHERE UPPER(DEPARTMENT_NAME) = UPPER(:OLD.DNAME);
  ELSE
    RAISE_APPLICATION_ERROR(-20007,'You cannot update any data other than department name!.');
  END IF;
END;
```

Exploring & Managing the triggers

`alter trigger trigger_name enable | disable;`
`alter table base_object_name [enable | disable] all triggers;`
`alter trigger trigger_name compile;`
`drop trigger trigger_name;`

Creating disabled triggers

```sql
--------------------------
create or replace trigger prevent_high_salary
before insert or update of salary on employees_copy
for each row
disable
when (new.salary > 50000)
begin
  raise_application_error(-20006,'A salary cannot be higher than 50000!.');
end;
```

Additional Real-World Examples for DML

```sql
/********************** Creating a Sequence ************************/
CREATE SEQUENCE seq_dep_cpy
START WITH 280
INCREMENT BY 10;

/********************** PRIMARY KEY Example ************************/
CREATE OR REPLACE TRIGGER trg_before_insert_dept_cpy
BEFORE INSERT ON departments_copy
FOR EACH ROW
BEGIN
  --SELECT seq_dep_cpy.nextval INTO :new.department_id FROM dual;
  :new.department_id := seq_dep_cpy.nextval;
END;

/*******************************************************************/
INSERT INTO departments_copy (department_name,manager_id,location_id)
    VALUES('Security',200,1700);

/*******************************************************************/
DESC departments_copy;

/******************** Creating The Audit Log Table *****************/
CREATE TABLE log_departments_copy
        (
         log_user             VARCHAR2(30),
         log_date             DATE,
         dml_type             VARCHAR2(10),
         old_department_id    NUMBER(4),
         new_department_id    NUMBER(4),
         old_department_name  VARCHAR2(30),
         new_department_name  VARCHAR2(30),
         old_manager_id       NUMBER(6),
         new_manager_id       NUMBER(6),
         old_location_id      NUMBER(4),
         new_location_id      NUMBER(4)
         );

/********************** Audit Log Trigger ************************/
CREATE OR REPLACE TRIGGER trg_department_copy_log
AFTER INSERT OR UPDATE OR DELETE ON departments_copy
FOR EACH ROW
DECLARE
    v_dml_type varchar2(10);
BEGIN
  IF inserting THEN
    v_dml_type := 'INSERT';
  ELSIF updating THEN
    v_dml_type := 'UPDATE';
  ELSIF deleting THEN
    v_dml_type := 'DELETE';
  END IF;
  INSERT INTO log_departments_copy
  VALUES ( user,
           sysdate,
           v_dml_type,
           :old.department_id,
           :new.department_id,
           :old.department_name,
           :new.department_name,
           :old.manager_id,
           :new.manager_id,
           :old.location_id,
           :new.location_id
          );

end;
/***** Other SQL Statements Used in This Lecture *****/
INSERT INTO departments_copy (department_name, manager_id,location_id)
     VALUES ('Cyber Security', 100, 1700);

SELECT * FROM log_departments_copy;

UPDATE departments_copy
SET manager_id = 200
WHERE department_name = 'Cyber Security';

DELETE FROM departments_copy
WHERE department_name = 'Cyber Security';
```

Compound Triggers

- a single trigger that allows us to specify actions for each DML trigger types
- share the variables, types etc among each other
- taking actions for various timing points by sharing the common data
- avoiding mutating table errors
- restrictions
  - a compound trigger must be a DML trigger defined on a table or view
  - a compound trigger body must be a compound trigger block
  - a compound trigger body cannot have an initialization block
  - the firing order of compound triggers is not guaranteed if don't use the `follows clause`

```sql
create [or replace] trigger trigger_name for insert | update | delete | update of column_list
    on object_name
    [reference old as old new as new]
    [when (condition)]
compound trigger
    [variables, types, etc]
    before statement is
        --PL/SQL block
        [exception]
    end before statement;

    before each row is
        --PL/SQL block
        [exception]
    end before each row;

    after each row is
        --PL/SQL block
        [exception]
    end after each row;

    after statement is
        --PL/SQL block
        [exception]
    end after statement;
end;
```

```sql
/********************************************************************/

------------------ The first simple compound trigger ----------------
create or replace trigger trg_comp_emps
for insert or update or delete on employees_copy
compound trigger

v_dml_type varchar2(10);

  before statement is
   begin
    if inserting then
      v_dml_type := 'INSERT';
    elsif updating then
      v_dml_type := 'UPDATE';
    elsif deleting then
      v_dml_type := 'DELETE';
    end if;
    dbms_output.put_line('Before statement section is executed with the '||v_dml_type ||' event!.');
  end before statement;

  before each row is
  t number;
    begin
      dbms_output.put_line('Before row section is executed with the '||v_dml_type ||' event!.');
  end before each row;

  after each row is
    begin
      dbms_output.put_line('After row section is executed with the '||v_dml_type ||' event!.');
  end after each row;

  after statement is
    begin
      dbms_output.put_line('After statement section is executed with the '||v_dml_type ||' event!.');
  end after statement;
end;
/*******************************************************************/
CREATE OR REPLACE TRIGGER TRG_COMP_EMPS
  FOR INSERT OR UPDATE OR DELETE ON EMPLOYEES_COPY
  COMPOUND TRIGGER

  TYPE T_AVG_DEPT_SALARIES IS TABLE OF EMPLOYEES_COPY.SALARY%TYPE INDEX BY PLS_INTEGER;
  AVG_DEPT_SALARIES T_AVG_DEPT_SALARIES;

  BEFORE STATEMENT IS
    BEGIN
      FOR AVG_SAL IN (SELECT AVG(SALARY) SALARY , NVL(DEPARTMENT_ID,999) DEPARTMENT_ID
                        FROM EMPLOYEES_COPY GROUP BY DEPARTMENT_ID) LOOP
        AVG_DEPT_SALARIES(AVG_SAL.DEPARTMENT_ID) := AVG_SAL.SALARY;
      END LOOP;
  END BEFORE STATEMENT;

  AFTER EACH ROW IS
    V_INTERVAL NUMBER := 15;
    BEGIN
       IF :NEW.SALARY > AVG_DEPT_SALARIES(:NEW.DEPARTMENT_ID) + AVG_DEPT_SALARIES(:NEW.DEPARTMENT_ID)*V_INTERVAL/100 THEN
        RAISE_APPLICATION_ERROR(-20005,'A raise cannot be '|| V_INTERVAL|| ' percent higher than
                                  its department''s average!');
       END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    BEGIN
      DBMS_OUTPUT.PUT_LINE('All the changes are done successfully!');
  END AFTER STATEMENT;

END;
```

Handling Mutating Table Errors

- return an error if an existing table is queried or modified again inside off the related trigger
- a mutating table:
  - a table that being modified
  - a table that might be updated with the DELETE CASCADE
- row level triggers cannot query or modify a mutating table
- the restriction prevents inconsistent data changes

```sql
/** ERROR Example **/
-- A mutating table error example: ----------------------------------
create or replace trigger trg_mutating_emps
before insert or update on employees_copy
for each row
declare

    v_interval number := 15;
    v_avg_salary number;

begin

    select avg(salary) into v_avg_salary from employees_copy where department_id = :new.department_id;
    if :new.salary > v_avg_salary*v_interval/100 then
        RAISE_APPLICATION_ERROR(-20005, 'A raise cannot be '|| v_interval|| ' percent higher than its department''s average');
    end if;
end;

/********************************************************************/
-- Getting mutating table error within a compound trigger: -----------
create or replace trigger trg_comp_emps
for insert or update or delete on employees_copy
compound trigger

  type t_avg_dept_salaries is table of employees_copy.salary%type index by pls_integer;
  avg_dept_salaries t_avg_dept_salaries;

  before statement is
   begin
    for avg_sal in (select avg(salary) salary,nvl(department_id,999) department_id from employees_copy group by department_id) loop
      avg_dept_salaries(avg_sal.department_id) := avg_sal.salary;
    end loop;
  end before statement;

  after each row is
    v_interval number := 15;
    begin
    update employees_copy set commission_pct = commission_pct;
      if :new.salary > avg_dept_salaries(:new.department_id)*v_interval/100 then
        RAISE_APPLICATION_ERROR(-20005, 'A raise cannot be '|| v_interval|| ' percent higher than its department''s average');
      end if;
  end after each row;

  after statement is
    begin
      dbms_output.put_line('All the updates are done successfully!.');
  end after statement;

end;

/********************************************************************/
-- An example of getting maximum level of recursive SQL levels: ------
create or replace trigger trg_comp_emps
for insert or update or delete on employees_copy
compound trigger

  type t_avg_dept_salaries is table of employees_copy.salary%type index by pls_integer;
  avg_dept_salaries t_avg_dept_salaries;

  before statement is
   begin
    update employees_copy set commission_pct = commission_pct where employee_id = 100;
    for avg_sal in (select avg(salary) salary,nvl(department_id,999) department_id from employees_copy group by department_id) loop
      avg_dept_salaries(avg_sal.department_id) := avg_sal.salary;
    end loop;
  end before statement;

  after each row is
    v_interval number := 15;
    begin
      if :new.salary > avg_dept_salaries(:new.department_id)*v_interval/100 then
        RAISE_APPLICATION_ERROR(-20005, 'A raise cannot be '|| v_interval|| ' percent higher than its department''s average');
      end if;
  end after each row;

  after statement is
    begin
      -- cause trigger loop, it fire the same triggers
      --update employees_copy set commission_pct = commission_pct where employee_id = 100;
      dbms_output.put_line('All the updates are done successfully!.');
  end after statement;

end;
```
