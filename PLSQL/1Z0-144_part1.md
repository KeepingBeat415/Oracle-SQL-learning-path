### Blocks

- compilation error means the code is checked for any typos and errors before run the code.

- anonymous blocks
- procedures
- functions

```sql
declare -- (optional)
    -- declaration
begin -- (mandatory)
    -- execution section (mandatory)
    -- exception handling (optional)
end; -- (mandatory)
```

- in PL/SQL developer, need to turn on DBMS_OUTPUT

```sql
set serveroutput on;
begin
    dbms_output.put_line('Hello World');
end;
```

### Variables

- PL/SQL variables types

  - scalar: holds a single value with one type
  - reference: holds value which point to a storage location, such as, pointer
  - large objects: as pointer to the value are stored outside of the table such as, images, files, etc.
  - composite: holds more than one value and can be in different types, such as, collection, records

#### scalar variable

- char(max_length): default value is 1
- varchar2(max_length): declare with max length, but able to store with real length, and not worst empty space
- number(precision, sale): fixed-length number data type with precision and scale
  - precision >= total number digit (integer + sale)
- binary_integer = plsinteger: less storage than numbers, but faster
- binary_float: allocates with 5 bytes of memory, ends with 'f' char, for example 2.07f.
- binary_double: allocates with 9 bytes of memory, ends with 'd' char, for example 2.07d.
- boolean: True/False, it can be NULL in the PL/SQL. Default: null
- date
- timestamp(precision): timestamp is an extension of date time, with milliseconds with the precision
- timestamp with time zone: extends timestamp data type including timezone
  - timezone is the different in hours and minutes between local time and coordinated universal time (Greenwich time)
- timestamp with local time zone: it stores as database system time zone, but when query it, Oracle server returns this value with your time zone with session
- interval year to month: set precisions for numbers of digits in year section
- interval day to second: manipulates intervals of days, hours, minutes and seconds

variable naming rules:

- must start with a letter
- contains '\_#$'
- less 30 characters

naming conventions:

- variable - v_variable_name, v_max
- cursor - cur_cursor_name, cur_employees
- exception - e_exception_name, e_invalid_salary
- procedure - p_procedure_name, p_calculate_salary
- bind variable - b_bind_name - b_emp_id

Declaring & Initializing & Using Variables

- either assign a value or set a default value
  `Name [CONSTANT] datatype [NOT NULL] [:= DEFAULT value|expression]`

```sql
declare
    v_text varchar2(50) not null default 'Hello';
    v_num_1 number(10) := 20.43;
    v_num_2 number(2) := 50.43;
    v_date_1 timestamp not null := sysdate;
        -- timestamp(precision)
    v_date_2 timestamp not null := sysdate;
    v_date_3 timestamp(3) not null := sysdate;
        -- timestamp(precision) range from 1 to 9, and default value is 6
begin
    dbms_output.put_line(v_num_1); -- 20.43
    dbms_output.put_line(v_num_2); -- 50
    dbms_output.put_line(v_date_1); -- 2-NOV-2024 09.04.17.133000 PM
    dbms_output.put_line(v_date_2); -- 2-NOV-2024 09.04.17.133000 PM +03:00
    dbms_output.put_line(v_date_3); -- 2-NOV-2024 09.04.17.133 PM
end;
```

interval

```sql

v_date_4 interval day(4) to second(2) := '24 02:05:21.012';
-- day(4) >> maximum value, second(2) for the maximum value of millisecond, default value 2 for day, and 6 for millisecond
-- OUTPUT: +0024 02:05:21:01

v_date_5 interval year to month := '12-3';
--default value 2 for day
--OUTPUT: +12-03
v_date_6 interval year(3) to month := '122-3';
--OUTPUT: +122-03

v_bool boolean := true;

```

Using %type attribute

- %type gets the datatype of the referenced column or value and assigns this datatype to the declared variable.
- NOT NULL column variable type still able assign to NULL, column constriction doesn't inheritance

```sql
declare
    v_type employees.job_id%type; -- not null constriction
begin
    v_type := null; -- still able assign to null
end;

```

Delimiters & Commenting

- @ : remote access
- ; : statement

PL/SQL Variable Scope

- cannot crate same named variables in the same block

```sql
begin <<outer>> -- add label
DECLARE
  --v_outer VARCHAR2(50) := 'Outer Variable!';
  v_text  VARCHAR2(20) := 'Out-text';
BEGIN
  DECLARE
    v_text  VARCHAR2(20) := 'In-text';
    v_inner VARCHAR2(30) := 'Inner Variable';
  BEGIN
    --dbms_output.put_line('inside -> ' || v_outer);
    --dbms_output.put_line('inside -> ' || v_inner);
      dbms_output.put_line('inner -> ' || v_text);
      dbms_output.put_line('outer -> ' || outer.v_text); -- using label to assign outer scope variable with same name
  END;
  --dbms_output.put_line('inside -> ' || v_inner); -- ERROR can't access inner variable
  --dbms_output.put_line(v_outer);
  dbms_output.put_line(v_text);
END;
END outer;
```

Using Bind variables

- increase performance
- it creates in the host environment, it works in the whole worksheet
- can't declare and assign value same time
- add `:` before variable name while assigning and using.

```sql
set autoprint on; -- prints all the bind variables that executed

variable var_text varchar2(30);
variable var_number number; -- can't assign with precisions and scales for example number(30) >> ERROR
-- variable var_date date; >> Error can't use with date type
-- declare bind variable
declare
    v_text varchar2(30);
begin
 :var_text := "Hello PL/SQL"; -- assign value to this bind variable
 v_text := :var_text;
end;
/
print var_text; -- print
```

### Control Structures

IF statement

```sql
if condition then statements;
[elsif condition then statements;]
...
[else statements;]
end if;
```

Case expressions

```sql
case [expression || condition]
    when conditions1 then result1
    [when conditions2 then result2]
    ...
    [else result]
end;
```

```sql
/****************** Simple Case Expression ******************/
DECLARE
  v_job_code        VARCHAR2(10) := 'SA_MAN';
  v_salary_increase NUMBER;
BEGIN
  v_salary_increase :=  CASE v_job_code
                         WHEN 'SA_MAN' THEN 0.2
                         WHEN 'SA_REP' THEN 0.3
                        ELSE 0
                        END;
  dbms_output.put_line('Your salary increase is : '|| v_salary_increase);
END;
/************************************************************/

/****************** Searched Case Expression ****************/
DECLARE
  v_job_code        VARCHAR2(10) := 'IT_PROG';
  v_department      VARCHAR2(10) := 'IT';
  v_salary_increase NUMBER;
BEGIN
  v_salary_increase:=CASE
                      WHEN v_job_code   = 'SA_MAN' THEN 0.2
                      WHEN v_department = 'IT' AND v_job_code = 'IT_PROG' THEN 0.3
                     ELSE 0
                     END;
  dbms_output.put_line('Your salary increase is : '|| v_salary_increase);
END;
/************************************************************/

/********************* CASE Statements **********************/
DECLARE
  v_job_code        VARCHAR2(10) := 'IT_PROG';
  v_department      VARCHAR2(10) := 'IT';
  v_salary_increase NUMBER;
BEGIN
  CASE
    WHEN v_job_code = 'SA_MAN' THEN
      v_salary_increase := 0.2;
      dbms_output.put_line('The salary increase for a Sales Manager is: '|| v_salary_increase);
    WHEN v_department = 'IT' AND v_job_code = 'IT_PROG' THEN
      v_salary_increase := 0.2;
      dbms_output.put_line('The salary increase for a Sales Manager is: '|| v_salary_increase);
    ELSE
      v_salary_increase := 0;
      dbms_output.put_line('The salary increase for this job code is: '|| v_salary_increase);
  END CASE;
END;
```

##### Loops

- Basic loops

  ```sql
  loop
      executable_statements;
      ...
      exit [when condition];
  end loop;
  ```

  ```sql
  declare
      v_counter number(2) := 1;
  begin
      loop
          dbms_output.put_line('Counter is: ' || v_counter);
          v_counter := v_counter + 1;

          exit when v_counter = 10; -- end loop
      end loop;
  end;
  /
  ```

- While loops

  ```sql
  while condition loop
      executable_statements;
  end loop
  ```

- For loops

  - cannot reach the counter outside of the loop
  - cannot assign any value to the counter
  - our bounds cannot be null

  ```sql
  for cnt in [REVERSE]
      lower_bound .. upper_bound loop

      executable_statements;
      ...
  end loop;
  ```

- Nesting and Labeling the Loops
  - use labels for loops
  - exiting the inner loop will not exit the outer
  - use labels to exit the outer loop

```sql
declare
    v_inner number := 1;
begin
<<outer_loop>> -- label outer loop
    for v_outer in 1..5 loop
        dbms_output.put_line('Outer value: '|| v_outer);
        v_inner := 1;
        <<inner_loop>> -- label inner loop
        loop
            v_inner := v_inner + 1;
                 dbms_output.put_line('Inner value: '|| v_inner);
                 --exit when v_inner*v_outer >= 15;

                 -- using label to call outer loop exit
                 exit outer_loop when v_inner*v_outer >= 16;
        end loop inner_loop;
    end loop outer_loop;
end;

```

- Continue Statement

```sql
    continue [label_name] [when condition];
```

```sql
/*********************** Example 1 **************************/
DECLARE
 v_inner NUMBER := 1;
BEGIN
 FOR v_outer IN 1..10 LOOP
  dbms_output.put_line('My outer value is : ' || v_outer );
    v_inner := 1;
    WHILE v_inner * v_outer < 15 LOOP
      v_inner := v_inner + 1;
      CONTINUE WHEN MOD(v_inner * v_outer,3) = 0;
      dbms_output.put_line('  My inner value is : ' || v_inner );
    END LOOP;
 END LOOP;
END;
/************************************************************/

-- using label
/*********************** Example 2 **************************/
DECLARE
 v_inner NUMBER := 1;
BEGIN
<<outer_loop>>
 FOR v_outer IN 1..10 LOOP
  dbms_output.put_line('My outer value is : ' || v_outer );
    v_inner := 1;
    <<inner_loop>>
    LOOP
      v_inner := v_inner + 1;
      CONTINUE outer_loop WHEN v_inner = 10;
      dbms_output.put_line('  My inner value is : ' || v_inner );
    END LOOP inner_loop;
 END LOOP outer_loop;
end;
/************************************************************/
```

- GOTO statement
  - can't with condition.
  - can't go to a control structure, for example, IF, CASE, LOOP
  - can't go to an inner block from the outer
  - can't go to IN or OUT of an exception handler

```sql
    GOTO label_name;
```

```sql
/******** Finding Prime Numbers Using GOTO Statement ********/
DECLARE
  v_searched_number NUMBER  := 22;
  v_is_prime        BOOLEAN := true;
BEGIN
  FOR x IN 2..v_searched_number-1 LOOP
    IF v_searched_number MOD x = 0 THEN
      dbms_output.put_line(v_searched_number|| ' is not a prime number..');
      v_is_prime := false;
      GOTO end_point;
    END IF;
  END LOOP;
  IF v_is_prime THEN
    dbms_output.put_line(v_searched_number|| ' is a prime number..');
  END IF;
<<end_point>>
  dbms_output.put_line('Check complete..');
END;

/************************************************************/
DECLARE
  v_searched_number NUMBER  := 32457;
  v_is_prime        BOOLEAN := TRUE;
  x                 NUMBER  := 2;
BEGIN
  <<start_point>>
    IF v_searched_number MOD x = 0 THEN
      dbms_output.put_line(v_searched_number|| ' is not a prime number..');
      v_is_prime := FALSE;
      GOTO end_point;
    END IF;
  x := x+1;
  IF x = v_searched_number THEN
    GOTO prime_point;
  END IF;
  GOTO start_point;
  <<prime_point>>
  IF v_is_prime THEN
    dbms_output.put_line(v_searched_number || ' is a prime number..');
  END IF;
<<end_point>>
  dbms_output.put_line('Check complete..');
END;
/************************************************************/
```

### Using SQL in PL/SQL

- cannot use DDL commands directly
- variable takes the precedence over the functions/tables

```sql
select columns|expressions into variables/records from table [where condition];
```

Using Sequences in PL/SQL

```sql
select sequence_name.nextval|currval into variable|column from table_name|dual;
```

### Composite Data Types

#### PL/SQL records

- record can have one or multiple values
- values can be at the same data type or with different types
- records only contains only _1 row_

Using table row as type

- copy the whole
  `r_name table_name%rowtype;`

```sql
/************************ Example 1 *************************/
DECLARE
  r_emp employees%rowtype;
BEGIN
  SELECT * INTO r_emp
  FROM   employees
  WHERE  employee_id = '101';
  --r_emp.salary := 2000;
  dbms_output.put_line(r_emp.first_name || ' '                ||
                       r_emp.last_name  || ' earns '          ||
                       r_emp.salary     || ' and hired at : ' ||
                       r_emp.hire_date);
END;
```

Create own row type

- all valid PL/SQL types, %type, %rowtype, not null and default keywords

```sql
type type_name is record(
    variable_name variable_type,
    [variable_name variable_type,]
    ....
);
```

```sql
/************************ Example 2 *************************/
DECLARE
  --r_emp employees%rowtype;
  type t_emp IS RECORD (first_name VARCHAR2(50),
                        last_name  employees.last_name%TYPE,
                        salary     employees.salary%TYPE,
                        hire_date  DATE);
  r_emp t_emp; -- declare record object
BEGIN
  SELECT first_name,last_name,salary,hire_date
  INTO   r_emp
  FROM   employees
  WHERE  employee_id = '101';

    -- modify record's value
 /* r_emp.first_name := 'Alex';
    r_emp.salary     := 2000;
    r_emp.hire_date  := '01-JAN-20'; */

  dbms_output.put_line(r_emp.first_name || ' '                ||
                       r_emp.last_name  || ' earns '          ||
                       r_emp.salary     || ' and hired at : ' ||
                       r_emp.hire_date);
END;

/************************ Example 3 *************************/
DECLARE
  TYPE t_edu is RECORD(primary_school    VARCHAR2(100),
                       high_school       VARCHAR2(100),
                       university        VARCHAR2(100),
                       uni_graduate_date DATE
                       );

  TYPE t_emp IS RECORD(first_name       VARCHAR2(50),
                       last_name        employees.last_name%type,
                       salary           employees.salary%type  NOT NULL DEFAULT 1000,
                       hire_date        DATE,
                       dept_id          employees.department_id%type,
                       department       departments%rowtype,
                       education        t_edu -- contains record type
                       );
  r_emp t_emp;
BEGIN
  SELECT first_name, last_name, salary, hire_date, department_id
    INTO r_emp.first_name, r_emp.last_name, r_emp.salary, r_emp.hire_date, r_emp.dept_id
    FROM employees where employee_id = '146';

  SELECT *
  INTO   r_emp.department
  FROM   departments
  WHERE  department_id = r_emp.dept_id;

  -- assign record type with values
  r_emp.education.high_school       := 'Beverly Hills';
  r_emp.education.university        := 'Oxford';
  r_emp.education.uni_graduate_date := '01-JAN-13';

  dbms_output.put_line(r_emp.first_name || ' '                ||
                       r_emp.last_name  || ' earns '          ||
                       r_emp.salary     || ' and hired at : ' ||
                       r_emp.hire_date);
  dbms_output.put_line('She graduated from '       ||
                       r_emp.education.university  ||
                       ' at '                      ||
                       r_emp.education.uni_graduate_date);
  dbms_output.put_line('Her Department Name is : '|| r_emp.department.department_name);
END;
/************************************************************/
```

Easy DML with records

- using `row` keyword to update existed row with record

```sql

DECLARE
    r_emp employees%rowtype;
BEGIN
    SELECT *
    INTO   r_emp
    FROM   employees
    WHERE  employee_id = 104;

    r_emp.salary         := 0;
    r_emp.commission_pct := 0;
    -- using record insert into table
    INSERT INTO retired_employees VALUES r_emp;
END;

/************************************************************/
DECLARE
    r_emp employees%rowtype;
BEGIN
    SELECT *
    INTO   r_emp
    FROM   employees
    WHERE  employee_id = 104;

    r_emp.salary         := 10;
    r_emp.commission_pct := 0;

    --update current rows with values of r_emp;
    UPDATE retired_employees
    SET    row = r_emp
    WHERE  employee_id = 104;
end;
/
/************************************************************/

```

#### Collections

- contains multiple rows
- a list of the same type
- three types of collection, Nested Tables, Varrays, Associative Arrays

---

Nested Tables

- index start from 1 (auto generated), and automatically increase with 1 each time
- unbounded
- key-value Pairs, key can have only numbers and subtypes like binary integers or PLS integers
- only positive number
- can't delete any values
- not stored consecutively
- 2GB limit for array size

```sql
  -- temporary nested table
  type type_name as table of value_data_type[not null];

  -- create that type in the database as schema-level type
  create or replace type type_name as table of value_data_type [not null];
```

```sql
/*********** The Simple Usage of Nested Tables **************/
DECLARE
  TYPE e_list IS TABLE OF VARCHAR2(50);
  emps e_list;
BEGIN
  emps := e_list('Alex','Bruce','John');
  FOR i IN 1..emps.count() LOOP
    dbms_output.put_line(emps(i));
  END LOOP;
END;

/************************************************************
Adding a New Value to a Nested Table After the Initialization
*************************************************************/
DECLARE
  TYPE e_list IS TABLE OF VARCHAR2(50);
  emps e_list;
BEGIN
  emps := e_list('Alex','Bruce','John');
  emps.extend;
  emps(4) := 'Bob';
  FOR i IN 1..emps.count() LOOP
    dbms_output.put_line(emps(i));
  END LOOP;
END;

/*************** Adding Values From a Table *****************/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%type;
  emps e_list := e_list();
  idx  PLS_INTEGER:= 1;
BEGIN
  FOR x IN 100 .. 110 LOOP
    emps.extend;
    SELECT first_name INTO emps(idx)
    FROM   employees
    WHERE  employee_id = x;
    idx := idx + 1;
  END LOOP;
  FOR i IN 1..emps.count() LOOP
    dbms_output.put_line(emps(i));
  END LOOP;
END;

/********************* Delete Example ***********************/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%type;
  emps e_list := e_list();
  idx  PLS_INTEGER := 1;
BEGIN
  FOR x IN 100 .. 110 LOOP
    emps.extend;
    SELECT first_name INTO emps(idx)
    FROM   employees
    WHERE  employee_id = x;
    idx := idx + 1;
  END LOOP;
  emps.delete(3); -- after delete, the array cell for this index will leave as NULL, cause issue when try to access it
  FOR i IN 1..emps.count() LOOP
    IF emps.exists(i) THEN
       dbms_output.put_line(emps(i));
    END IF;
  END LOOP;
END;
```

---

VARRAYs

- index start from 1 (auto generated), and automatically increase with 1 each time
- bounded, the table size can't change after the declaration
- varrays are one dimentional arrays
- varrays are null by default
- 2GB limit for array size

```sql
/**************** A Simple Working Example ******************/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob','Richard');
  FOR i IN 1..5 LOOP
    dbms_output.put_line(employees(i));
  END LOOP;
END;

/************** Limit Exceeding Error Example ***************/
DECLARE
  TYPE e_list IS VARRAY(4) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob','Richard');
  FOR i IN 1..5 LOOP
    dbms_output.put_line(employees(i));
  END LOOP;
END;

/*********** Subscript Beyond Count Error Example ***********/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob');
  FOR i IN 1..5 LOOP
    dbms_output.put_line(employees(i));
  end loop;
END;

/**************** A Working count() Example *****************/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob');
  for i IN 1..employees.count() LOOP
    dbms_output.put_line(employees(i));
  END LOOP;
END;

/************ A Working first() last() Example **************/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob');
  FOR i IN employees.first()..employees.last() LOOP
    dbms_output.put_line(employees(i));
  END LOOP;
END;

/*************** A Working exists() Example *****************/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob');
  FOR i IN 1..5 LOOP
    IF employees.exists(i) THEN
      dbms_output.put_line(employees(i));
    END IF;
  END LOOP;
END;

/**************** A Working limit() Example *****************/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list;
BEGIN
  employees := e_list('Alex','Bruce','John','Bob');
  dbms_output.put_line(employees.limit());
END;

/****** A Create-Declare at the Same Time Error Example *****/
DECLARE
  TYPE e_list IS VARRAY(5) OF VARCHAR2(50);
  employees e_list('Alex','Bruce','John','Bob');
BEGIN
  --employees := e_list('Alex','Bruce','John','Bob');
  FOR i IN 1..5 LOOP
    IF employees.exists(i) THEN
       dbms_output.put_line(employees(i));
    END IF;
  END LOOP;
END;

/************** A Post Insert Varray Example ****************/
DECLARE
  TYPE e_list IS VARRAY(15) OF VARCHAR2(50);
  employees e_list := e_list();
  idx NUMBER := 1;
BEGIN
  FOR i IN 100..110 LOOP
    employees.extend;
    SELECT first_name
    INTO   employees(idx)
    FROM   employees
    WHERE  employee_id = i;
    idx := idx + 1;
  END LOOP;
  FOR x IN 1..employees.count() LOOP
    dbms_output.put_line(employees(x));
  END LOOP;
END;

/******* An Example for the Schema-Level Varray Types *******/
CREATE TYPE e_list IS VARRAY(15) OF VARCHAR2(50);
/
CREATE OR REPLACE TYPE e_list AS VARRAY(20) OF VARCHAR2(100);
/
DECLARE
  employees e_list := e_list();
  idx       NUMBER := 1;
BEGIN

  FOR i IN 100..110 LOOP
    employees.extend;
    SELECT first_name
    INTO employees(idx)
    FROM employees
    WHERE employee_id = i;
    idx := idx + 1;
  END LOOP;

  FOR x IN 1..employees.count() LOOP
    dbms_output.put_line(employees(x));
  END LOOP;

END;
/
DROP TYPE E_LIST;
```

---

Associate Arrays

- can specify the value of the keys
- key can be Integer/String, unique
- keys does not need to be sequential
- can have scalar & record types
- associative arrays are indexed, using a varchar key type, it is indexed as 'B-TREE' index.
  - 'B-TREE' faster in the traverse
- unbounded
- cannot create this type in the schema-level

```sql
type type_name as table of value_data_type [not null] index by {PLS_INTEGER | BINARY_INTEGER | VARCHAR2(SIZE)};
```

```sql
/********************* The First Example ********************/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emps e_list;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT first_name
    INTO   emps(x)
    FROM   employees
    WHERE  employee_id = x ;
  END LOOP;

  -- using .first(), .last(), because the associate array not sequential
  FOR i IN emps.first()..emps.last() LOOP
    dbms_output.put_line(emps(i));
  END LOOP;
END;

/********* Error Example for the SELECT INTO Clause *********/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emps e_list;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT first_name
    INTO   emps(x)
    FROM   employees
    WHERE  employee_id   = x
    AND    department_id = 60;
  END LOOP;
  FOR i IN emps.first()..emps.last() LOOP
    dbms_output.put_line(i);
  END LOOP;
END;

/******* Error Example about Reaching an Empty Index ********/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emps e_list;
BEGIN
  emps(100) := 'Bob';
  emps(120) := 'Sue';
  FOR i IN emps.first()..emps.last() LOOP
    -- it cause error, since the loop begin from 100 until 120,
    -- but 101 to 119 are empty index cell
    -- using emps(i) not return value and cause ERROR
    dbms_output.put_line(emps(i));
  END LOOP;
END;

/*************************************************************
An Example of Iterating in Associative Arrays with WHILE LOOPs
*************************************************************/
DECLARE
  TYPE e_list IS TABLE OF employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emps e_list;
  idx  PLS_INTEGER;
BEGIN
  emps(100) := 'Bob';
  emps(120) := 'Sue';
  idx       := emps.first;

  WHILE idx IS NOT NULL LOOP
    dbms_output.put_line(emps(idx));
    idx := emps.next(idx);
  END LOOP;
END;

/*************************************************************
An Example of Using String-based Indexes with Associative Arrays
*************************************************************/
DECLARE
  -- using string based indexed
  TYPE e_list IS TABLE OF employees.first_name%TYPE INDEX BY employees.email%type;
  emps         e_list;
  idx          employees.email%TYPE;
  v_email      employees.email%TYPE;
  v_first_name employees.first_name%TYPE;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT first_name, email
    INTO   v_first_name, v_email
    FROM   employees
    WHERE  employee_id = x;
    emps(v_email) := v_first_name;
  END LOOP;

  idx := emps.first;
  WHILE idx IS NOT NULL LOOP
    dbms_output.put_line('The email of '|| emps(idx) ||' is : '|| idx);
    idx := emps.next(idx);
  END LOOP;
END;

/*** An Example of Using Associative Arrays with Records ****/
DECLARE
  TYPE e_list IS TABLE OF employees%rowtype INDEX BY employees.email%TYPE;
  emps e_list;
  idx  employees.email%type;
BEGIN
  -- using number as index, but it's accepted as String
  FOR x IN 100 .. 110 LOOP
    SELECT *
    INTO   emps(x)
    FROM   employees
    WHERE  employee_id = x;
  END LOOP;

  idx := emps.first;

  WHILE idx IS NOT NULL LOOP
    dbms_output.put_line('The email of '      ||
                         emps(idx).first_name || ' '     ||
                         emps(idx).last_name  || ' is : '|| emps(idx).email);
    idx := emps.next(idx);
  END LOOP;
END;

/* An Example of Using Associative Arrays with Record Types */
DECLARE
  TYPE e_type IS RECORD (first_name employees.first_name%TYPE,
                         last_name  employees.last_name%TYPE,
                         email      employees.email%TYPE);
  TYPE e_list IS TABLE OF e_type INDEX BY employees.email%TYPE;
  emps e_list;
  idx  employees.email%type;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT first_name,last_name,email
    INTO   emps(x)
    FROM   employees
    WHERE  employee_id = x;
  END LOOP;

  idx := emps.first;

  WHILE idx IS NOT NULL LOOP
    dbms_output.put_line('The email of '       ||
                          emps(idx).first_name || ' ' ||
                          emps(idx).last_name  || ' is : ' ||
                          emps(idx).email);
    idx := emps.next(idx);
  END LOOP;
END;

/**** An Example of Printing From the Last to the First *****/
DECLARE
  TYPE e_type IS RECORD (first_name employees.first_name%TYPE,
                         last_name  employees.last_name%TYPE,
                         email      employees.email%TYPE);
  TYPE e_list IS TABLE OF e_type INDEX BY employees.email%TYPE;
  emps e_list;
  idx  employees.email%type;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT first_name,last_name, email
    INTO   emps(x)
    FROM   employees
    WHERE  employee_id = x;
  END LOOP;

  --emps.delete(100,104); -- using delete by index
  idx := emps.last; -- backward

  WHILE idx IS NOT NULL LOOP
    dbms_output.put_line('The email of '       ||
                          emps(idx).first_name || ' '     ||
                          emps(idx).last_name  ||' is : ' ||
                          emps(idx).email);
    idx := emps.prior(idx); -- using .prior(), to traversal backward
  END LOOP;
END;

/***** An Example of Inserting with Associative Arrays ******/
CREATE TABLE employees_salary_history
AS SELECT * FROM employees WHERE 1=2;

ALTER TABLE employees_salary_history ADD insert_date DATE;

SELECT * FROM employees_salary_history;
/
DECLARE
  TYPE e_list IS TABLE OF employees_salary_history%rowtype INDEX BY PLS_INTEGER;
  emps e_list;
  idx  PLS_INTEGER;
BEGIN
  FOR x IN 100 .. 110 LOOP
    SELECT e.*,'01-JUN-20'
    INTO   emps(x)
    FROM   employees e
    WHERE  employee_id = x;
  END LOOP;

  idx := emps.first;

  WHILE idx IS NOT NULL LOOP
    emps(idx).salary := emps(idx).salary + emps(idx).salary*0.2;
    INSERT INTO employees_salary_history VALUES emps(idx);
    dbms_output.put_line('The employee '       || emps(idx).first_name ||
                         ' is inserted to the history table');
    idx := emps.next(idx);
  END LOOP;
END;
/
DROP TABLE employees_salary_history;
```

---

Storing Collection in Tables

##### varrays

- can store varrays and nested tables in database level
- stored with different methods
- store and use easier-faster
- types must be schema level,which means not includes associate arrays
- fixed length and can't modify anymore, it will cause "cannot drop or replace a type with type or table dependents" error

```sql
/***************** Storing Varray Example *******************/
-- record can't be schema level, using object
CREATE OR REPLACE TYPE t_phone_number AS OBJECT(p_type   VARCHAR2(10),
                                                p_number VARCHAR2(50)
                                               );
/
CREATE OR REPLACE TYPE v_phone_numbers AS VARRAY(3) OF t_phone_number;
/
CREATE TABLE emps_with_phones(employee_id  NUMBER,
                              first_name   VARCHAR2(50),
                              last_name    VARCHAR2(50),
                              phone_number v_phone_numbers);
/
SELECT * FROM emps_with_phones;
/
INSERT INTO emps_with_phones
VALUES(10,'Alex','Brown',v_phone_numbers(t_phone_number('HOME','111.111.1111'),
                                         t_phone_number('WORK','222.222.2222'),
                                         t_phone_number('MOBILE','333.333.3333'))
                                         );
INSERT INTO emps_with_phones
VALUES(11,'Bob','Green',v_phone_numbers(t_phone_number('HOME','000.000.000'),
                                         t_phone_number('WORK','444.444.4444'))
                                         );
/

-- column phone_number is not in a readable format.
-- using join table
-- table() operator enables us to use the collections just like a table
/*************** Querying the Varray Example ****************/
SELECT e.first_name,
       last_name,
       p.p_type,
       p.p_number
FROM emps_with_phones e, table(e.phone_number) p; -- e.phone_number is the column of table
```

##### Nested table

- storing that nested table in the storage table.
- can't

```sql
/****** The Code For the Storing Nested Table Example *******/
CREATE OR REPLACE TYPE n_phone_numbers AS TABLE OF t_phone_number;
/
CREATE TABLE emps_with_phones2(employee_id  NUMBER,
                               first_name   VARCHAR2(50),
                               last_name    VARCHAR2(50),
                               phone_number n_phone_numbers)
                               NESTED TABLE phone_number STORE AS phone_numbers_table; -- storage table
/
SELECT * FROM emps_with_phones2;
/
INSERT INTO emps_with_phones2
VALUES(10,'Alex','Brown',n_phone_numbers(t_phone_number('HOME','111.111.1111'),
                                         t_phone_number('WORK','222.222.2222'),
                                         t_phone_number('MOBILE','333.333.3333'))
                                         );
INSERT INTO emps_with_phones2
VALUES(11,'Bob','Green',n_phone_numbers(t_phone_number('HOME','000.000.000'),
                                        t_phone_number('WORK','444.444.4444'))
                                        );
/
SELECT e.first_name, last_name, p.p_type, p.p_number
FROM emps_with_phones2 e, table(e.phone_number) p;

/***************** New Insert and Update ********************/
INSERT INTO emps_with_phones2
VALUES(11,'Bob','Green',n_phone_numbers(t_phone_number('HOME','000.000.000'),
                                        t_phone_number('WORK','444.444.4444'),
                                        t_phone_number('WORK2','444.444.4444'),
                                        t_phone_number('WORK3','444.444.4444'),
                                        t_phone_number('WORK4','444.444.4444'),
                                        t_phone_number('WORK5','444.444.4444'))
                                        );
SELECT * FROM emps_with_phones2;

UPDATE emps_with_phones2
SET phone_number = n_phone_numbers(t_phone_number('HOME','000.000.000'),
                                   t_phone_number('WORK','444.444.4444'),
                                   t_phone_number('WORK2','444.444.4444'),
                                   t_phone_number('WORK3','444.444.4444'),
                                   t_phone_number('WORK4','444.444.4444'),
                                   t_phone_number('WORK5','444.444.4444'))
WHERE employee_id = 11;

/**** Adding a New Value into a Nested Inside of a Table ****/
DECLARE
  p_num n_phone_numbers;
BEGIN
  SELECT phone_number
  INTO   p_num
  FROM   emps_with_phones2
  WHERE  employee_id = 10;

  p_num.extend;
  p_num(6) := t_phone_number('FAX','999.99.9999');

  UPDATE emps_with_phones2
  SET    phone_number = p_num
  WHERE  employee_id  = 10;
END;
/************************************************************/
```

### PL/SQL Cursors

- Cursors are pointers to the data
  - implicit cursor
  - explicit cursor
- can't go back in cursors
- the cursor usage
  - declare
  - open
  - fetch
  - check
  - close

```sql
declare
    cursor cursor_name is select_statement;
begin
    open cursor_name;
    fetch cursor_name into variables, records etc;
    close cursor_name;
end;
```

```sql
declare
  cursor c_emps is select first_name,last_name from employees;
  v_first_name employees.first_name%type;
  v_last_name employees.last_name%type;
begin
  open c_emps;
  -- every fetch will return the next row
  fetch c_emps into v_first_name,v_last_name;
  fetch c_emps into v_first_name,v_last_name;
  fetch c_emps into v_first_name,v_last_name;
  dbms_output.put_line(v_first_name|| ' ' || v_last_name);
  fetch c_emps into v_first_name,v_last_name;
  dbms_output.put_line(v_first_name|| ' ' || v_last_name);
  close c_emps;
end;
--------------- cursor with join example
declare
  cursor c_emps is select first_name,last_name, department_name from employees
                      join departments using (department_id)
                      where department_id between 30 and 60;
  v_first_name employees.first_name%type;
  v_last_name employees.last_name%type;
  v_department_name departments.department_name%type;
begin
  open c_emps;
  fetch c_emps into v_first_name, v_last_name,v_department_name;
  dbms_output.put_line(v_first_name|| ' ' || v_last_name|| ' in the department of '|| v_department_name);
  close c_emps;
end;
```

Using Cursors with Records

```sql
declare
  type r_emp is record (  v_first_name employees.first_name%type,
                           v_last_name employees.last_name%type);
  v_emp r_emp;
  cursor c_emps is select first_name,last_name from employees;
begin
  open c_emps;
  fetch c_emps into v_emp;
  dbms_output.put_line(v_emp.v_first_name|| ' ' || v_emp.v_last_name);
  close c_emps;
end;

--------------- An example for using cursors table rowtype
declare
  v_emp employees%rowtype;
  cursor c_emps is select first_name,last_name from employees;
begin
  open c_emps;
  fetch c_emps into v_emp.first_name,v_emp.last_name;
  dbms_output.put_line(v_emp.first_name|| ' ' || v_emp.last_name);
  close c_emps;
end;

--------------- An example for using cursors with cursor%rowtype.
declare
  cursor c_emps is select first_name,last_name from employees;
  v_emp c_emps%rowtype;
begin
  open c_emps;
  fetch c_emps into v_emp.first_name,v_emp.last_name;
  dbms_output.put_line(v_emp.first_name|| ' ' || v_emp.last_name);
  close c_emps;
end;
```

Looping with Cursors

```sql
declare
  cursor c_emps is select * from employees where department_id = 30;
  v_emps c_emps%rowtype;
begin
  open c_emps;
  loop
    fetch c_emps into v_emps;
    dbms_output.put_line(v_emps.employee_id|| ' ' ||v_emps.first_name|| ' ' ||v_emps.last_name);
    -- infinite loop, will keep try to print last row
  end loop;
  close c_emps;
end;

---------------%notfound example
declare
  cursor c_emps is select * from employees where department_id = 30;
  v_emps c_emps%rowtype;
begin
  open c_emps;
  loop
    fetch c_emps into v_emps;
    exit when c_emps%notfound;
    dbms_output.put_line(v_emps.employee_id|| ' ' ||v_emps.first_name|| ' ' ||v_emps.last_name);
  end loop;
  close c_emps;
end;

---------------while loop example
declare
  cursor c_emps is select * from employees where department_id = 30;
  v_emps c_emps%rowtype;
begin
  open c_emps;
  fetch c_emps into v_emps;
  while c_emps%found loop
    dbms_output.put_line(v_emps.employee_id|| ' ' ||v_emps.first_name|| ' ' ||v_emps.last_name);
    fetch c_emps into v_emps;
    --exit when c_emps%notfound;
  end loop;
  close c_emps;
end;

---------------for loop with cursor example
declare
  cursor c_emps is select * from employees where department_id = 30;
  v_emps c_emps%rowtype;
begin
  open c_emps;
  for i in 1..6 loop
    fetch c_emps into v_emps;
    dbms_output.put_line(v_emps.employee_id|| ' ' ||v_emps.first_name|| ' ' ||v_emps.last_name);
  end loop;
  close c_emps;
end;

---------------FOR..IN clause example
declare
  cursor c_emps is select * from employees where department_id = 30;
begin
  for i in c_emps loop
    dbms_output.put_line(i.employee_id|| ' ' ||i.first_name|| ' ' ||i.last_name);
  end loop;
end;

---------------FOR..IN with select example
begin

  for i in (select * from employees where department_id = 30) loop
    dbms_output.put_line(i.employee_id|| ' ' ||i.first_name|| ' ' ||i.last_name);
  end loop;
end;
```

PL/SQL Cursors with Parameters

```sql
declare
    cursor cursor_name(parameter_name datatype, ...)
    is select_statement;
begin
    open cursor_name(parameter_values);
    fetch cursor_name into variables, records etc;
    close cursor_name;
end;
```

```sql
declare
  cursor c_emps (p_dept_id number) is select first_name,last_name,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id;
  v_emps c_emps%rowtype;
begin
  open c_emps(20);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
  close c_emps;

  open c_emps(20);
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound;
      dbms_output.put_line(v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;
end;

--------------- bind variables as parameters
declare
  cursor c_emps (p_dept_id number) is select first_name,last_name,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id;
  v_emps c_emps%rowtype;
begin
  open c_emps(:b_emp);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
  close c_emps;

  open c_emps(:b_emp);
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound;
      dbms_output.put_line(v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;
end;

--------------- cursors with two different parameters
declare
  cursor c_emps (p_dept_id number) is select first_name,last_name,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id;
  v_emps c_emps%rowtype;
begin
  open c_emps(:b_dept_id);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
  close c_emps;

  open c_emps(:b_dept_id);
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound;
      dbms_output.put_line(v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;

  open c_emps(:b_dept_id2);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
  close c_emps;

  open c_emps(:b_dept_id2);
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound;
      dbms_output.put_line(v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;
end;

--------------- cursor with parameters - for in loops
declare
  cursor c_emps (p_dept_id number) is select first_name,last_name,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id;
  v_emps c_emps%rowtype;
begin
  open c_emps(:b_dept_id);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
    close c_emps;

  open c_emps(:b_dept_id);
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound;
      dbms_output.put_line(v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;

  open c_emps(:b_dept_id2);
  fetch c_emps into v_emps;
    dbms_output.put_line('The employees in department of '|| v_emps.department_name|| ' are :');
    close c_emps;

    for i in c_emps(:b_dept_id2) loop
      dbms_output.put_line(i.first_name|| ' ' ||i.last_name);
    end loop;
end;

---------------cursors with multiple parameters
declare
  cursor c_emps (p_dept_id number , p_job_id varchar2) is select first_name,last_name,job_id,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id
                    and job_id = p_job_id;
  v_emps c_emps%rowtype;
begin
    for i in c_emps(50,'ST_MAN') loop
      dbms_output.put_line(i.first_name|| ' ' ||i.last_name|| ' - ' || i.job_id);
    end loop;

    dbms_output.put_line(' - ');

    for i in c_emps(80,'SA_MAN') loop
      dbms_output.put_line(i.first_name|| ' ' ||i.last_name|| ' - ' || i.job_id);
    end loop;
end;

--------------- An **error** example of using parameter name with the column name
declare
  cursor c_emps (p_dept_id number , job_id varchar2) is select first_name,last_name,job_id,department_name
                    from employees join departments using (department_id)
                    where department_id = p_dept_id
                    and job_id = job_id; -- cause error, parameter has same name as column
  v_emps c_emps%rowtype;
begin
    for i in c_emps(50,'ST_MAN') loop
      dbms_output.put_line(i.first_name|| ' ' ||i.last_name|| ' - ' || i.job_id);
    end loop;

    dbms_output.put_line(' - ');

    for i in c_emps(80,'SA_MAN') loop
      dbms_output.put_line(i.first_name|| ' ' ||i.last_name|| ' - ' || i.job_id);
    end loop;
end;
```

PL/SQL Cursor Attributes

- there are four cursor attributes
  - `%FOUND` returns true if the fetch returned a row
  - `%NOTFOUND` opposite of %FOUND
  - `%ISOPEN` returns true if the cursor is open
  - `%ROWCOUNT` returns the number of fetched rows, which fetched up to now

```sql
declare
  cursor c_emps is select * from employees where department_id = 50;
  v_emps c_emps%rowtype;
begin
  if not c_emps%isopen then
    open c_emps;
    dbms_output.put_line('hello');
  end if;

  dbms_output.put_line(c_emps%rowcount);
  fetch c_emps into v_emps;
  dbms_output.put_line(c_emps%rowcount);
  dbms_output.put_line(c_emps%rowcount);
  fetch c_emps into v_emps;
  dbms_output.put_line(c_emps%rowcount);
  close c_emps;

  open c_emps;
    loop
      fetch c_emps into v_emps;
      exit when c_emps%notfound or c_emps%rowcount>5;
      dbms_output.put_line(c_emps%rowcount|| ' ' ||v_emps.first_name|| ' ' ||v_emps.last_name);
    end loop;
  close c_emps;
end;
```

For Update Clause

- when you update a row, it is locked to the others
- "for update" clause locks the selected rows
- "nowait" option will terminate execution if there is a lock
- default option is "wait"
- "for update of" clause locks only the selected tables

```sql
cursor cursor_name(parameter_name datatype, ...)
    is select_statement
    for update [of columns(s)] [nowait | wait n];
```

```sql
grant create session to my_user;
grant select any table to my_user;
grant update on hr.employees_copy to my_user;
grant update on hr.departments to my_user;
UPDATE EMPLOYEES_COPY SET PHONE_NUMBER = '1' WHERE EMPLOYEE_ID = 100;

declare
  cursor c_emps is select employee_id,first_name,last_name,department_name
      from employees_copy join departments using (department_id)
      where employee_id in (100,101,102)
      for update;
begin
  /* for r_emps in c_emps loop
    update employees_copy set phone_number = 3
      where employee_id = r_emps.employee_id;
  end loop; */
  open c_emps; -- opened cursor, then lock table
end;

--------------- example of wait with second
declare
  cursor c_emps is select employee_id,first_name,last_name,department_name
      from employees_copy join departments using (department_id)
      where employee_id in (100,101,102)
      for update of employees_copy.phone_number,
      departments.location_id wait 5; -- row level locked
begin
  /* for r_emps in c_emps loop
    update employees_copy set phone_number = 3
      where employee_id = r_emps.employee_id;
  end loop; */
  open c_emps;
end;

---------------example of nowait
declare
  cursor c_emps is select employee_id,first_name,last_name,department_name
      from employees_copy join departments using (department_id)
      where employee_id in (100,101,102)
      for update of employees_copy.phone_number,
      departments.location_id nowait;
begin
  /* for r_emps in c_emps loop
    update employees_copy set phone_number = 3
      where employee_id = r_emps.employee_id;
  end loop; */
  open c_emps;
end;
```

Where Current of Clause

- using rowid to improve update speed

```sql
declare
  cursor c_emps is select * from employees
                    where department_id = 30 for update;
begin
  for r_emps in c_emps loop
    update employees set salary = salary + 60
          where current of c_emps;
  end loop;
end;

/** ERROR  **/
---------------Wrong example of using where current of clause
declare
  cursor c_emps is select e.* from employees e, departments d
                    where
                    e.department_id = d.department_id
                    and e.department_id = 30 for update;
                    -- error, after join table, Oracle can't decide take which rowid
begin
  for r_emps in c_emps loop
    update employees set salary = salary + 60
          where current of c_emps;
  end loop;
end;

---------------An example of using rowid like where current of clause
declare
  cursor c_emps is select e.rowid,e.salary from employees e, departments d
                    where
                    e.department_id = d.department_id
                    and e.department_id = 30 for update;
                    -- using rowid with join table
begin
  for r_emps in c_emps loop
    update employees set salary = salary + 60
          where rowid = r_emps.rowid;
  end loop;
end;
```

Reference Cursors

- Cursors are pointers
- cannot
  - assign null values
  - use in table-view create codes
  - store in collections
  - compare
- two type of reference cursors, return type restriction
  - strong (restrictive) cursors
  - weak (nonrestrictive) cursors

```sql
type cursor_type_name is ref cursor [return return_type];
```

```sql
declare
 type t_emps is ref cursor return employees%rowtype;
 rc_emps t_emps;
 r_emps employees%rowtype;
begin
  open rc_emps for select * from employees;
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name);
    end loop;
  close rc_emps;
end;

--------------- in two different queries
declare
 type t_emps is ref cursor return employees%rowtype;
 rc_emps t_emps;
 r_emps employees%rowtype;
begin
  open rc_emps for select * from retired_employees;
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name);
    end loop;
  close rc_emps;

  dbms_output.put_line('--------------');

  open rc_emps for select * from employees where job_id = 'IT_PROG';
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name);
    end loop;
  close rc_emps;
end;

---------------Example of using with %type when declaring records first
declare
  r_emps employees%rowtype;
 type t_emps is ref cursor return r_emps%type;
 rc_emps t_emps;
 --type t_emps2 is ref cursor return rc_emps%rowtype;
begin
  open rc_emps for select * from retired_employees;
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name);
    end loop;
  close rc_emps;

  dbms_output.put_line('--------------');

  open rc_emps for select * from employees where job_id = 'IT_PROG';
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name);
    end loop;
  close rc_emps;
end;

---------------manually declared record type with cursors example
declare
  type ty_emps is record (e_id number,
                         first_name employees.first_name%type,
                         last_name employees.last_name%type,
                         department_name departments.department_name%type);
 r_emps ty_emps;
 -- if using a manually created record type, we simply writ only the name of the record type
 type t_emps is ref cursor return ty_emps;
 rc_emps t_emps;
begin
  open rc_emps for select employee_id,first_name,last_name,department_name
                      from employees join departments using (department_id);
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name||
            ' is at the department of : '|| r_emps.department_name );
    end loop;
  close rc_emps;
end;

---------------first example of weak ref cursors
declare
  type ty_emps is record (e_id number,
                         first_name employees.first_name%type,
                         last_name employees.last_name%type,
                         department_name departments.department_name%type);
 r_emps ty_emps;
 type t_emps is ref cursor;
 rc_emps t_emps;
 q varchar2(200);
begin
  q := 'select employee_id,first_name,last_name,department_name
                      from employees join departments using (department_id)';
  open rc_emps for q;
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name||
            ' is at the department of : '|| r_emps.department_name );
    end loop;
  close rc_emps;
end;

--------------- bind variables with cursors example
declare
  type ty_emps is record (e_id number,
                         first_name employees.first_name%type,
                         last_name employees.last_name%type,
                         department_name departments.department_name%type);
 r_emps ty_emps;
 type t_emps is ref cursor;
 rc_emps t_emps;
 r_depts departments%rowtype;
 --r t_emps%rowtype;
 q varchar2(200);
begin
  q := 'select employee_id,first_name,last_name,department_name
                      from employees join departments using (department_id)
                      where department_id = :t';
  open rc_emps for q using '50'; -- using clause assign value into ':t'
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name||
            ' is at the department of : '|| r_emps.department_name );
    end loop;
  close rc_emps;

  open rc_emps for select * from departments;
    loop
      fetch rc_emps into r_depts;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_depts.department_id|| ' ' || r_depts.department_name);
    end loop;
  close rc_emps;
end;

-- sys_refcursor is a built-in weak reference cursor type that we can use in any result-set between other blocks or subprograms or even with another platforms like Java, etc.

---------------sys_refcursor example
declare
  type ty_emps is record (e_id number,
                         first_name employees.first_name%type,
                         last_name employees.last_name%type,
                         department_name departments.department_name%type);
 r_emps ty_emps;
-- type t_emps is ref cursor;
 rc_emps sys_refcursor; -- declare sys_refcursor
 r_depts departments%rowtype;
 --r t_emps%rowtype;
 q varchar2(200);
begin
  q := 'select employee_id,first_name,last_name,department_name
                      from employees join departments using (department_id)
                      where department_id = :t';
  open rc_emps for q using '50';
    loop
      fetch rc_emps into r_emps;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_emps.first_name|| ' ' || r_emps.last_name||
            ' is at the department of : '|| r_emps.department_name );
    end loop;
  close rc_emps;

  open rc_emps for select * from departments;
    loop
      fetch rc_emps into r_depts;
      exit when rc_emps%notfound;
      dbms_output.put_line(r_depts.department_id|| ' ' || r_depts.department_name);
    end loop;
  close rc_emps;
end;
```
